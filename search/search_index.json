{"config":{"lang":["nl"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LHM-Ribasim","text":"<p>Het Landelijk Hydrologisch Model (LHM) op basis van Local Surface Water (LSW) eenheden en het netwerk van het DistributieModel (DM) voor Ribasim.jl</p> <p></p> <p>Documentatie: https://d2hydro.github.io/lhm-ribasim</p> <p>Broncode: https://github.com/d2hydro/lhm-ribasim</p>"},{"location":"#auteurs","title":"Auteurs","text":""},{"location":"#inleiding","title":"Inleiding","text":""},{"location":"get_started/","title":"Gebruikershandleiding","text":""},{"location":"get_started/#downloaden-data","title":"Downloaden data","text":"<ul> <li>Download de bestanden van Deltares-ftp in <code>path\\naar\\de\\repos\\data</code>. Zie voor de juiste structuur en beschrijving: https://github.com/d2hydro/lhm-ribasim/tree/main/data</li> </ul> <p>## Runnen test-model  - Installeer RIBASIM volgens de handleiding. Unzip de inhoud van ribasim_cli.zip in de root van de resporitory, <code>path\\naar\\de\\repos\\ribasim_cli</code>.  - Run het test-model in een cmd met <code>path\\naar\\de\\repos\\scripts\\run_test_model.cmd</code>. Dit levert het volgende resultaat:</p> <p></p> <p>## Opzetten Python environment  - Bouw je environment met https://github.com/d2hydro/lhm-ribasim/blob/main/envs/environment_dev_spyder.yml - Clone de Deltares RIBASIM repository: https://github.com/Deltares/Ribasim - Run in de geactiveerde conda-environment <code>pip install -e .</code> in de ribasim repository in de sub-folder <code>python\\ribasim</code> (je vindt daar en pyproject.toml file)</p>"},{"location":"notebooks/bouw_lhm_netwerk/","title":"Bouw LHM netwerk","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport pandas as pd\nfrom config import load_src, DATA_DIR, MOZART_DIR, LSW_DIR, LHM_DIR\nimport networkx as nx\nfrom networkx import NetworkXNoPath\nfrom networkx.classes.function import path_weight\nload_src()\nfrom lhm.read import (\n    read_lsw_routing,\n    read_dw_keys,\n    read_dm_mz_to_obese,\n    read_sobek_network_shps,\n    read_dm_network_shps,\n    read_lkm_network_links\n    )\nfrom lhm.lsw import lsw_end_nodes, lsw_network\nfrom lhm.network import merge_lsm_lkm, create_graph, Network\nfrom lhm.utils import report_progress\nfrom shapely.geometry import LineString\n</pre> import geopandas as gpd import pandas as pd from config import load_src, DATA_DIR, MOZART_DIR, LSW_DIR, LHM_DIR import networkx as nx from networkx import NetworkXNoPath from networkx.classes.function import path_weight load_src() from lhm.read import (     read_lsw_routing,     read_dw_keys,     read_dm_mz_to_obese,     read_sobek_network_shps,     read_dm_network_shps,     read_lkm_network_links     ) from lhm.lsw import lsw_end_nodes, lsw_network from lhm.network import merge_lsm_lkm, create_graph, Network from lhm.utils import report_progress from shapely.geometry import LineString In\u00a0[2]: Copied! <pre># Inlezen lsw-routing\nlsw_routing_dik = MOZART_DIR / r\"mozartin/lswrouting.dik\"\nlsw_routing_df = read_lsw_routing(lsw_routing_dik)\n\n# Inlezen en dissolven lsws\nlsw_gdf = gpd.read_file(LSW_DIR / \"lsws.shp\").dissolve(by=\"LSWFINAL\").reset_index()\n\n# bouwen lsw-netwerk\nlsw_links_gdf, lsw_nodes_gdf = lsw_network(lsw_gdf, lsw_routing_df, dissolve_lsws=False)\n</pre> # Inlezen lsw-routing lsw_routing_dik = MOZART_DIR / r\"mozartin/lswrouting.dik\" lsw_routing_df = read_lsw_routing(lsw_routing_dik)  # Inlezen en dissolven lsws lsw_gdf = gpd.read_file(LSW_DIR / \"lsws.shp\").dissolve(by=\"LSWFINAL\").reset_index()  # bouwen lsw-netwerk lsw_links_gdf, lsw_nodes_gdf = lsw_network(lsw_gdf, lsw_routing_df, dissolve_lsws=False)  In\u00a0[3]: Copied! <pre># afleiden lsw-end-nodes\nlsw_end_nodes_gdf = lsw_end_nodes(lsw_links_gdf, lsw_nodes_gdf).reset_index()\nlsw_end_nodes_gdf[\"lsw_lkm\"] = lsw_end_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\")\nlsw_end_nodes_gdf = lsw_end_nodes_gdf[[\"LSWFINAL\", \"lsw_lkm\", \"DWRN\", \"geometry\"]]\n\nlsw_nodes_gdf.reset_index(inplace=True)\nlsw_nodes_gdf[\"lsw_lkm\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\")\nlsw_nodes_gdf.set_index(\"LSWFINAL\", inplace=True)\n\nprint(f\"aantal lsw-eindknopen: {len(lsw_end_nodes_gdf)}\")\nlsw_end_nodes_gdf.explore()\n</pre> # afleiden lsw-end-nodes lsw_end_nodes_gdf = lsw_end_nodes(lsw_links_gdf, lsw_nodes_gdf).reset_index() lsw_end_nodes_gdf[\"lsw_lkm\"] = lsw_end_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\") lsw_end_nodes_gdf = lsw_end_nodes_gdf[[\"LSWFINAL\", \"lsw_lkm\", \"DWRN\", \"geometry\"]]  lsw_nodes_gdf.reset_index(inplace=True) lsw_nodes_gdf[\"lsw_lkm\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\") lsw_nodes_gdf.set_index(\"LSWFINAL\", inplace=True)  print(f\"aantal lsw-eindknopen: {len(lsw_end_nodes_gdf)}\") lsw_end_nodes_gdf.explore() <pre>aantal lsw-eindknopen: 2309\n</pre> Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre># Inlezen LSM-netwerk\nnetwork_l_gdf, network_n_gdf = read_sobek_network_shps(\n    DATA_DIR.joinpath(\"LSM_obsese\", \"LSMKRW\")\n    )\n\n# Inlezen DMMZTOSOBEKID_obese.txt\ndm_mz_to_obese_txt = DATA_DIR.joinpath(\"LSM_obsese\", \"DMMZTOSOBEKID_obese.txt\")\ndm_mz_to_obese_df = read_dm_mz_to_obese(dm_mz_to_obese_txt)\ndm_mz_to_obese_df = dm_mz_to_obese_df[\n    dm_mz_to_obese_df[\"LSM_id\"].isin(network_n_gdf.index)\n    ]\nlat_discharge_mask = dm_mz_to_obese_df[\"flow_type\"] == \"D\"\nlat_extraction_mask = dm_mz_to_obese_df[\"flow_type\"] == \"E\"\n\n# Inlezen LKM25_links.shp\nlkm25_links_shp = DATA_DIR.joinpath(\"lkm25\",\"Schematisatie\",\"KRWVerkenner\",\"shapes\",\"LKM25_Links.shp\")\nlkm25_links_gdf = read_lkm_network_links(lkm25_links_shp)\n\n# Inlezen dwkeys.txt\ndw_keys_df = read_dw_keys(DATA_DIR / r\"lhm4.3\\\\dm\\\\txtfiles_git\\\\dwkeys.txt\")\ndw_discharge_mask = dw_keys_df[\"kty\"] == \"d\"\ndw_extractions_mask = dw_keys_df[\"kty\"] == \"e\"\n\n# Inlezen DM-netwerk\ndm_links_gdf, dm_nodes_gdf = read_dm_network_shps(LHM_DIR / r\"dm/data_dvc\")\n</pre> # Inlezen LSM-netwerk network_l_gdf, network_n_gdf = read_sobek_network_shps(     DATA_DIR.joinpath(\"LSM_obsese\", \"LSMKRW\")     )  # Inlezen DMMZTOSOBEKID_obese.txt dm_mz_to_obese_txt = DATA_DIR.joinpath(\"LSM_obsese\", \"DMMZTOSOBEKID_obese.txt\") dm_mz_to_obese_df = read_dm_mz_to_obese(dm_mz_to_obese_txt) dm_mz_to_obese_df = dm_mz_to_obese_df[     dm_mz_to_obese_df[\"LSM_id\"].isin(network_n_gdf.index)     ] lat_discharge_mask = dm_mz_to_obese_df[\"flow_type\"] == \"D\" lat_extraction_mask = dm_mz_to_obese_df[\"flow_type\"] == \"E\"  # Inlezen LKM25_links.shp lkm25_links_shp = DATA_DIR.joinpath(\"lkm25\",\"Schematisatie\",\"KRWVerkenner\",\"shapes\",\"LKM25_Links.shp\") lkm25_links_gdf = read_lkm_network_links(lkm25_links_shp)  # Inlezen dwkeys.txt dw_keys_df = read_dw_keys(DATA_DIR / r\"lhm4.3\\\\dm\\\\txtfiles_git\\\\dwkeys.txt\") dw_discharge_mask = dw_keys_df[\"kty\"] == \"d\" dw_extractions_mask = dw_keys_df[\"kty\"] == \"e\"  # Inlezen DM-netwerk dm_links_gdf, dm_nodes_gdf = read_dm_network_shps(LHM_DIR / r\"dm/data_dvc\") In\u00a0[5]: Copied! <pre>import warnings\nwarnings.filterwarnings(\"ignore\")\n\n# combineren lsm-lkm netwerk\nnetwork_links_gdf, network_nodes_gdf = merge_lsm_lkm(lkm25_links_gdf, network_l_gdf, network_n_gdf)\n\nnetwork_nodes_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"nodes\")\nnetwork_links_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"links\")\n\n# afleiden netwerk-graaf\nnetwork_graph = create_graph(network_links_gdf, network_nodes_gdf)\n</pre> import warnings warnings.filterwarnings(\"ignore\")  # combineren lsm-lkm netwerk network_links_gdf, network_nodes_gdf = merge_lsm_lkm(lkm25_links_gdf, network_l_gdf, network_n_gdf)  network_nodes_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"nodes\") network_links_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"links\")  # afleiden netwerk-graaf network_graph = create_graph(network_links_gdf, network_nodes_gdf) In\u00a0[6]: Copied! <pre>lsw_end_nodes_in_network_gdf = lsw_end_nodes_gdf[\n    lsw_end_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)\n    ]\n\nlinks = []\n\n\nnbr_groups = len(lsw_end_nodes_in_network_gdf[\"DWRN\"].unique())\nfor idx, (district, _lsw_end_nodes_df) in enumerate(lsw_end_nodes_in_network_gdf.groupby(\"DWRN\")):\n    report_progress(idx+1, nbr_groups, interval=5)\n\n    # find dm_nodes to couple with\n    \n    dm_nodes = dw_keys_df[\n        (dw_keys_df[\"oid\"] == district) &amp; dw_discharge_mask\n        ][\"nid\"].to_list()\n    \n    if not dm_nodes:\n        dm_nodes = dm_mz_to_obese_df[\n            (dm_mz_to_obese_df[\"DWRN\"] == district) &amp; lat_discharge_mask\n            ][\"DM\"].to_list()\n    \n    # find possible LSM laterals discharging to DM nodes\n    dm_mz_to_obese_select_df = dm_mz_to_obese_df[\n        dm_mz_to_obese_df[\"DM\"].isin(dm_nodes) &amp; lat_discharge_mask\n        ]\n    \n    missing_dm_links = dm_nodes\n    missing_lsw_links = []\n    \n    # couple all lsw-end-nodes to DM-node(s)\n    for row in _lsw_end_nodes_df.itertuples():\n        lsw_from = row.LSWFINAL\n        lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]\n        # find the shortest path between LSW-node and DM-node\n        for dm_to, _dm_mz_lat_df in dm_mz_to_obese_select_df.groupby(\"DM\"):\n            path_found = False\n            dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]\n            paths = []\n            path_lengths = []\n            valid_laterals = _dm_mz_lat_df[\"LSM_id\"]\n            for lateral in valid_laterals:\n                try:\n                    path = nx.shortest_path(network_graph, source=row.lsw_lkm, target=lateral, weight=\"length\", method='dijkstra')\n                    # Exclude paths that pass through other lateral nodes\n                    if all(node not in valid_laterals for node in path[1:-1]):\n                        path = [i for i in path if not i.startswith(\"LKM_\")]\n                        length = path_weight(network_graph, path, weight=\"length\")\n                        paths.append(path)\n                        path_lengths.append(length)\n                except NetworkXNoPath:\n                    continue\n            if paths:\n                path_found = True\n                path = paths[path_lengths.index(min(path_lengths))]\n                lsm_to = path[0]\n        \n                # define geometry\n                lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]\n    \n                # find idx of closest lsm-node to dm-node\n                distances = [i.distance(dm_node) for i in lsm_nodes]\n                idx = distances.index(min(distances))\n                geometry = LineString(([lsw_node] + lsm_nodes[:idx+1] + [dm_node]))\n                links += [(row.LSWFINAL, lsm_to, dm_to, district, \"discharge\", geometry)]\n                \n                missing_dm_links = [i for i in missing_dm_links if i != dm_to]\n    \n        if not path_found:\n            missing_lsw_links += [lsw_from]\n    \n    # make sure every lsw has a link to# a DM node\n    for lsw_from in missing_lsw_links:\n        lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]\n        dm_to = dm_nodes_gdf.loc[dm_nodes, \"geometry\"].distance(lsw_node).idxmin()\n        dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]\n        geometry = LineString([lsw_node, dm_node])\n        links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]\n        missing_dm_links = [i for i in missing_dm_links if i != dm_to]\n    \n    # make sure every DM #is discharged from a LSW\n    for dm_to in missing_dm_links:\n        dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]\n        lsw_from = _lsw_end_nodes_df.set_index(\"LSWFINAL\").distance(dm_node).idxmin()\n        lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]\n        geometry = LineString([lsw_node, dm_node])\n        links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]\n\nafvoer_links_gdf = gpd.GeoDataFrame(\n    data=links,\n    columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],\n    crs=28992)\n\nafvoer_links_gdf[\"node_from\"] = afvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\")\nafvoer_links_gdf[\"node_to\"] = afvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\")\nafvoer_links_gdf[\"link_type\"] = \"LSW-DM\"\nafvoer_links_gdf[\"index\"] = afvoer_links_gdf.apply(\n    (lambda x: f\"{x.node_from}-{x.node_to}\"),\n    axis=1\n    )\n</pre> lsw_end_nodes_in_network_gdf = lsw_end_nodes_gdf[     lsw_end_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)     ]  links = []   nbr_groups = len(lsw_end_nodes_in_network_gdf[\"DWRN\"].unique()) for idx, (district, _lsw_end_nodes_df) in enumerate(lsw_end_nodes_in_network_gdf.groupby(\"DWRN\")):     report_progress(idx+1, nbr_groups, interval=5)      # find dm_nodes to couple with          dm_nodes = dw_keys_df[         (dw_keys_df[\"oid\"] == district) &amp; dw_discharge_mask         ][\"nid\"].to_list()          if not dm_nodes:         dm_nodes = dm_mz_to_obese_df[             (dm_mz_to_obese_df[\"DWRN\"] == district) &amp; lat_discharge_mask             ][\"DM\"].to_list()          # find possible LSM laterals discharging to DM nodes     dm_mz_to_obese_select_df = dm_mz_to_obese_df[         dm_mz_to_obese_df[\"DM\"].isin(dm_nodes) &amp; lat_discharge_mask         ]          missing_dm_links = dm_nodes     missing_lsw_links = []          # couple all lsw-end-nodes to DM-node(s)     for row in _lsw_end_nodes_df.itertuples():         lsw_from = row.LSWFINAL         lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]         # find the shortest path between LSW-node and DM-node         for dm_to, _dm_mz_lat_df in dm_mz_to_obese_select_df.groupby(\"DM\"):             path_found = False             dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]             paths = []             path_lengths = []             valid_laterals = _dm_mz_lat_df[\"LSM_id\"]             for lateral in valid_laterals:                 try:                     path = nx.shortest_path(network_graph, source=row.lsw_lkm, target=lateral, weight=\"length\", method='dijkstra')                     # Exclude paths that pass through other lateral nodes                     if all(node not in valid_laterals for node in path[1:-1]):                         path = [i for i in path if not i.startswith(\"LKM_\")]                         length = path_weight(network_graph, path, weight=\"length\")                         paths.append(path)                         path_lengths.append(length)                 except NetworkXNoPath:                     continue             if paths:                 path_found = True                 path = paths[path_lengths.index(min(path_lengths))]                 lsm_to = path[0]                          # define geometry                 lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]                      # find idx of closest lsm-node to dm-node                 distances = [i.distance(dm_node) for i in lsm_nodes]                 idx = distances.index(min(distances))                 geometry = LineString(([lsw_node] + lsm_nodes[:idx+1] + [dm_node]))                 links += [(row.LSWFINAL, lsm_to, dm_to, district, \"discharge\", geometry)]                                  missing_dm_links = [i for i in missing_dm_links if i != dm_to]              if not path_found:             missing_lsw_links += [lsw_from]          # make sure every lsw has a link to# a DM node     for lsw_from in missing_lsw_links:         lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]         dm_to = dm_nodes_gdf.loc[dm_nodes, \"geometry\"].distance(lsw_node).idxmin()         dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]         geometry = LineString([lsw_node, dm_node])         links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]         missing_dm_links = [i for i in missing_dm_links if i != dm_to]          # make sure every DM #is discharged from a LSW     for dm_to in missing_dm_links:         dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]         lsw_from = _lsw_end_nodes_df.set_index(\"LSWFINAL\").distance(dm_node).idxmin()         lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]         geometry = LineString([lsw_node, dm_node])         links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]  afvoer_links_gdf = gpd.GeoDataFrame(     data=links,     columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],     crs=28992)  afvoer_links_gdf[\"node_from\"] = afvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\") afvoer_links_gdf[\"node_to\"] = afvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\") afvoer_links_gdf[\"link_type\"] = \"LSW-DM\" afvoer_links_gdf[\"index\"] = afvoer_links_gdf.apply(     (lambda x: f\"{x.node_from}-{x.node_to}\"),     axis=1     ) <pre>[####################] 100.0% completed\r</pre> In\u00a0[7]: Copied! <pre># Graaf omzetten naar undirected\nif network_graph.is_directed():\n    network_graph = network_graph.to_undirected()\nlsw_nodes_in_network_gdf = lsw_nodes_gdf[\n    lsw_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)\n    ]\n# Zoeken naar links\nlinks = []\nnbr_groups = len(dw_keys_df[dw_extractions_mask][\"oid\"].unique())\nfor idx, (district, _extract_df) in enumerate(dw_keys_df[dw_extractions_mask].groupby(\"oid\")):\n    report_progress(idx+1, nbr_groups, interval=5)\n    #print(f\"district: {district}\")\n    dm_nodes = _extract_df[\"nid\"]\n    for dm_from in dm_nodes.values:\n        #print(f\"   dm-node: {dm_from}\")\n        dm_node = dm_nodes_gdf.at[dm_from, \"geometry\"]\n        \n        paths = []\n        path_lengths = []\n        lsws = []\n        dm_mz_to_obese_select_df = dm_mz_to_obese_df[\n            (dm_mz_to_obese_df[\"DM\"] == dm_from) &amp; lat_extraction_mask &amp; (dm_mz_to_obese_df[\"DWRN\"] == district)\n            ]\n        lsw_district_nodes_df = lsw_end_nodes_in_network_gdf[lsw_end_nodes_in_network_gdf[\"DWRN\"] == district]\n        \n        if lsw_district_nodes_df.empty:\n            lsw_district_nodes_df = lsw_nodes_in_network_gdf[lsw_nodes_in_network_gdf[\"DWRN\"] == district]\n            lsw_district_nodes_df.reset_index(inplace=True)\n            \n        if not dm_mz_to_obese_select_df.empty:\n            lsm_from = dm_mz_to_obese_select_df[\"LSM_id\"].values[0]\n            lkm_lsw_nodes = lsw_district_nodes_df[\"lsw_lkm\"]\n            for row in lsw_district_nodes_df.itertuples():\n                lsw_lkm_to = row.lsw_lkm\n                try:\n                    path = nx.shortest_path(network_graph, source=lsm_from, target=lsw_lkm_to, weight=\"length\", method='dijkstra')\n                    # Exclude paths that pass through other lateral nodes\n                    if all(node not in lkm_lsw_nodes for node in path[1:-1]):\n                        #path = [i for i in path if not i.startswith(\"LKM_\")]\n                        length = path_weight(network_graph, path, weight=\"length\")\n                        paths.append(path)\n                        path_lengths.append(length)\n                except NetworkXNoPath:\n                    continue\n        if paths:\n            idx = path_lengths.index(min(path_lengths))\n            path = paths[idx]\n            lsw_to = int(path[-1][4:])\n            path = [i for i in path if not i.startswith(\"LKM_\")]\n            lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]\n            \n            # define geometry\n            lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]\n            geometry = LineString(([dm_node] + lsm_nodes + [lsw_node]))\n            \n            links += [(lsw_to, lsm_from, dm_from, district, \"extraction\", geometry)]\n        else:\n            lsw = lsw_district_nodes_df.loc[lsw_district_nodes_df.distance(dm_node).idxmin()]\n            lsw_to = lsw.LSWFINAL\n            lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]\n            geometry = LineString([dm_node, lsw_node])\n            links += [(lsw_to, None, dm_from, district, \"extraction\", geometry)]\n\naanvoer_links_gdf = gpd.GeoDataFrame(\n                    data=links,\n                    columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],\n                    crs=28992)\n\naanvoer_links_gdf[\"node_from\"] = aanvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\")\naanvoer_links_gdf[\"node_to\"] = aanvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\")\naanvoer_links_gdf[\"link_type\"] = \"DM-LSW\"\naanvoer_links_gdf[\"index\"] = aanvoer_links_gdf.apply(\n    (lambda x: f\"{x.node_from}-{x.node_to}\"),\n    axis=1\n    )\n</pre> # Graaf omzetten naar undirected if network_graph.is_directed():     network_graph = network_graph.to_undirected() lsw_nodes_in_network_gdf = lsw_nodes_gdf[     lsw_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)     ] # Zoeken naar links links = [] nbr_groups = len(dw_keys_df[dw_extractions_mask][\"oid\"].unique()) for idx, (district, _extract_df) in enumerate(dw_keys_df[dw_extractions_mask].groupby(\"oid\")):     report_progress(idx+1, nbr_groups, interval=5)     #print(f\"district: {district}\")     dm_nodes = _extract_df[\"nid\"]     for dm_from in dm_nodes.values:         #print(f\"   dm-node: {dm_from}\")         dm_node = dm_nodes_gdf.at[dm_from, \"geometry\"]                  paths = []         path_lengths = []         lsws = []         dm_mz_to_obese_select_df = dm_mz_to_obese_df[             (dm_mz_to_obese_df[\"DM\"] == dm_from) &amp; lat_extraction_mask &amp; (dm_mz_to_obese_df[\"DWRN\"] == district)             ]         lsw_district_nodes_df = lsw_end_nodes_in_network_gdf[lsw_end_nodes_in_network_gdf[\"DWRN\"] == district]                  if lsw_district_nodes_df.empty:             lsw_district_nodes_df = lsw_nodes_in_network_gdf[lsw_nodes_in_network_gdf[\"DWRN\"] == district]             lsw_district_nodes_df.reset_index(inplace=True)                      if not dm_mz_to_obese_select_df.empty:             lsm_from = dm_mz_to_obese_select_df[\"LSM_id\"].values[0]             lkm_lsw_nodes = lsw_district_nodes_df[\"lsw_lkm\"]             for row in lsw_district_nodes_df.itertuples():                 lsw_lkm_to = row.lsw_lkm                 try:                     path = nx.shortest_path(network_graph, source=lsm_from, target=lsw_lkm_to, weight=\"length\", method='dijkstra')                     # Exclude paths that pass through other lateral nodes                     if all(node not in lkm_lsw_nodes for node in path[1:-1]):                         #path = [i for i in path if not i.startswith(\"LKM_\")]                         length = path_weight(network_graph, path, weight=\"length\")                         paths.append(path)                         path_lengths.append(length)                 except NetworkXNoPath:                     continue         if paths:             idx = path_lengths.index(min(path_lengths))             path = paths[idx]             lsw_to = int(path[-1][4:])             path = [i for i in path if not i.startswith(\"LKM_\")]             lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]                          # define geometry             lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]             geometry = LineString(([dm_node] + lsm_nodes + [lsw_node]))                          links += [(lsw_to, lsm_from, dm_from, district, \"extraction\", geometry)]         else:             lsw = lsw_district_nodes_df.loc[lsw_district_nodes_df.distance(dm_node).idxmin()]             lsw_to = lsw.LSWFINAL             lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]             geometry = LineString([dm_node, lsw_node])             links += [(lsw_to, None, dm_from, district, \"extraction\", geometry)]  aanvoer_links_gdf = gpd.GeoDataFrame(                     data=links,                     columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],                     crs=28992)  aanvoer_links_gdf[\"node_from\"] = aanvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\") aanvoer_links_gdf[\"node_to\"] = aanvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\") aanvoer_links_gdf[\"link_type\"] = \"DM-LSW\" aanvoer_links_gdf[\"index\"] = aanvoer_links_gdf.apply(     (lambda x: f\"{x.node_from}-{x.node_to}\"),     axis=1     ) <pre>[####################] 100.0% completed\r</pre> In\u00a0[8]: Copied! <pre># DM-netwerk voorbereiden\ndm_links_gdf[\"node_from\"] = dm_links_gdf[\"node_from\"].apply(lambda x: f\"DMnd_{x}\")\ndm_links_gdf[\"node_to\"] = dm_links_gdf[\"node_to\"].apply(lambda x: f\"DMnd_{x}\")\ndm_links_gdf[\"index\"] = dm_links_gdf[\"index\"].apply(lambda x: f\"DMlk_{x}\")\ndm_links_gdf[\"link_type\"] = \"DM-DM\"\ndm_nodes_gdf[\"index\"] = dm_nodes_gdf[\"index\"].apply(lambda x: f\"DMnd_{x}\")\n\n# LSW-netwerk voorbreiden\nlsw_links_gdf[\"node_from\"] = lsw_links_gdf[\"node_from\"].apply(lambda x: f\"MZlsw_{x}\")\nlsw_links_gdf[\"node_to\"] = lsw_links_gdf[\"node_to\"].apply(lambda x: f\"MZlsw_{x}\")\nlsw_links_gdf[\"index\"] = lsw_links_gdf.apply((lambda x: f\"{x.node_from}-{x.node_to}\"), axis=1)\nlsw_links_gdf[\"link_type\"] = \"LSW-LSW\"\nlsw_nodes_gdf.reset_index(inplace=True)\nlsw_nodes_gdf[\"index\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x: f\"MZlsw_{x}\")\n\n# Samenstellen netwerk-links\nlinks_gdf = pd.concat(\n    [lsw_links_gdf,\n     afvoer_links_gdf,\n     aanvoer_links_gdf,\n     dm_links_gdf]\n    )\n\n# Samenstellen netwerk-nodes\nnodes_gdf = pd.concat([lsw_nodes_gdf, dm_nodes_gdf])\n\n# aanmaken lhm-netwerk en wegschrijven\nlhm_netwerk = Network(nodes=nodes_gdf, links=links_gdf)\nlhm_netwerk.to_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\")\n\nlhm_netwerk.explore()\n</pre> # DM-netwerk voorbereiden dm_links_gdf[\"node_from\"] = dm_links_gdf[\"node_from\"].apply(lambda x: f\"DMnd_{x}\") dm_links_gdf[\"node_to\"] = dm_links_gdf[\"node_to\"].apply(lambda x: f\"DMnd_{x}\") dm_links_gdf[\"index\"] = dm_links_gdf[\"index\"].apply(lambda x: f\"DMlk_{x}\") dm_links_gdf[\"link_type\"] = \"DM-DM\" dm_nodes_gdf[\"index\"] = dm_nodes_gdf[\"index\"].apply(lambda x: f\"DMnd_{x}\")  # LSW-netwerk voorbreiden lsw_links_gdf[\"node_from\"] = lsw_links_gdf[\"node_from\"].apply(lambda x: f\"MZlsw_{x}\") lsw_links_gdf[\"node_to\"] = lsw_links_gdf[\"node_to\"].apply(lambda x: f\"MZlsw_{x}\") lsw_links_gdf[\"index\"] = lsw_links_gdf.apply((lambda x: f\"{x.node_from}-{x.node_to}\"), axis=1) lsw_links_gdf[\"link_type\"] = \"LSW-LSW\" lsw_nodes_gdf.reset_index(inplace=True) lsw_nodes_gdf[\"index\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x: f\"MZlsw_{x}\")  # Samenstellen netwerk-links links_gdf = pd.concat(     [lsw_links_gdf,      afvoer_links_gdf,      aanvoer_links_gdf,      dm_links_gdf]     )  # Samenstellen netwerk-nodes nodes_gdf = pd.concat([lsw_nodes_gdf, dm_nodes_gdf])  # aanmaken lhm-netwerk en wegschrijven lhm_netwerk = Network(nodes=nodes_gdf, links=links_gdf) lhm_netwerk.to_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\")  lhm_netwerk.explore() Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"notebooks/bouw_lhm_netwerk/#bouw-lhm-netwerk","title":"Bouw LHM netwerk\u00b6","text":"<ol> <li>Afleiden LSW-netwerk: local service waters (lsws) waarvan een routing naar een andere lsw bekend is, routen we naar deze lsw. Dit levert tevens een lijst met <code>lsw-end-nodes</code> op, die in stap 2 aan het DM worden gekoppeld</li> <li>AFleiden LSW-DM-links: <code>lsw-end-nodes</code> worden gekoppeld aan het DM via een gecombineerd netwerk van het Landelijk KRW verkenner model (<code>LKM</code>) en het landelijk Sobek Model (<code>LSM</code>). Voor het <code>LSM</code> is een lijst bekend van lateralen die afwateren naar of aanvoeren vanuit districten en DM-knopen.</li> <li>Opbouw LHM-netwerk: het DM-netwerk nemen we over, het LSW-netwerk (<code>1</code>) en de  LSW-DM-links (<code>2</code>) worden daarmee geintegreerd.</li> </ol>"},{"location":"notebooks/bouw_lhm_netwerk/#1-lsw-netwerk","title":"1. LSW-netwerk\u00b6","text":"<p>We lezen <code>lswrouting.dik</code> (beschrijft lsw-naar-lsw-routing) en <code>lsws.shp</code>. Met de functie <code>lsw_network</code> kunnen we hier een lsw-netwerk van bouwen met <code>lsw_links_gdf</code> en <code>lsw_nodes_gdf</code>. De functie <code>lsw_end_nodes</code> levert ons lsw eindknopen op die we moeten koppelen aan het DM.</p>"},{"location":"notebooks/bouw_lhm_netwerk/#11-bouwen-lsw-netwerk","title":"1.1. Bouwen lsw-netwerk\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#12-afleiden-lsw-eindknopen","title":"1.2. Afleiden LSW-eindknopen\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#2-lsw-dm-links","title":"2. LSW-DM-links\u00b6","text":"<p>We doorlopen de volgende stappen:</p> <ol> <li>Inlezen:<ul> <li>LSM-netwerk: <code>network_l.shp</code> en <code>network_n.shp</code> met de functie <code>read_sobek_network_shps</code></li> <li><code>DMMZTOSOBEKID_obese.txt</code> met functie <code>read_dm_mz_to_obese</code></li> <li><code>LKM25_links.shp</code> met functie <code>read_lkm_network_links</code></li> <li><code>dwkeys.txt</code> met functie <code>read_dw_keys</code></li> <li>DM-netwerk met <code>read_dm_network_shps</code></li> </ul> </li> <li>Bouwen van lkm-lsm netwerk bestanden met functie <code>merge_lsm_lkm</code> en omzetten naar een netwerk-graaf</li> <li>Afleiden afvoerlinks uit de graaf</li> <li>Afleiden van aanvoerlinks uit de graaf</li> </ol>"},{"location":"notebooks/bouw_lhm_netwerk/#21-inlezen","title":"2.1. Inlezen\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#22-bouwen-lsm-lkm-netwerk-graaf","title":"2.2. Bouwen LSM-LKM netwerk + graaf\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#23-afleiden-afvoerlinks","title":"2.3 Afleiden afvoerlinks\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#24-afleiden-aanvoerlinks","title":"2.4 Afleiden aanvoerlinks\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#3-opbouw-lhm-netwerk","title":"3. Opbouw LHM-netwerk\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/","title":"Bouw Ribasim schematisatie","text":"In\u00a0[1]: Copied! <pre>from config import LHM_DIR, DATA_DIR, MODEL_DIR, load_src\nimport geopandas as gpd\nimport pandas as pd\nimport xarray as xr\nimport numpy as np\n\nload_src()\n\nfrom lhm.network import Network\nfrom lhm.utils import next_index\n</pre> from config import LHM_DIR, DATA_DIR, MODEL_DIR, load_src import geopandas as gpd import pandas as pd import xarray as xr import numpy as np  load_src()  from lhm.network import Network from lhm.utils import next_index In\u00a0[2]: Copied! <pre>model_name=\"ribasim_model_flevoland\"\nmask_gdf = gpd.read_file(DATA_DIR / \"mask.gpkg\")\nmask_poly = mask_gdf.iloc[0].geometry\nbbox = mask_poly.bounds\n#bbox = None\n</pre> model_name=\"ribasim_model_flevoland\" mask_gdf = gpd.read_file(DATA_DIR / \"mask.gpkg\") mask_poly = mask_gdf.iloc[0].geometry bbox = mask_poly.bounds #bbox = None In\u00a0[3]: Copied! <pre>lhm_netwerk = Network.from_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\")\nlhm_netwerk.explore()\n</pre> lhm_netwerk = Network.from_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\") lhm_netwerk.explore() Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebooks/bouw_ribasim_schematisatie/#bouw-ribasim-schematisatie","title":"Bouw Ribasim schematisatie\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#modelnaam-en-clip-mask","title":"Modelnaam en clip-mask\u00b6","text":"<p>Hieronder hebben we een optie om een model te maken van heel Nederland of een stukje Nederland:</p> <ul> <li><code>model_name</code>: naam voor het Ribasim model</li> <li><code>mask_poly</code>: GeoPackage met polygon</li> </ul>"},{"location":"notebooks/bouw_ribasim_schematisatie/#1-inlezen-lhm-netwerk","title":"1. Inlezen LHM-netwerk\u00b6","text":""}]}