{"config":{"lang":["nl"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LHM-Ribasim","text":"<p>Het Landelijk Hydrologisch Model (LHM) op basis van Local Surface Water (LSW) eenheden en het netwerk van het DistributieModel (DM) voor Ribasim.jl</p> <p></p> <p>Documentatie: https://d2hydro.github.io/lhm-ribasim</p> <p>Broncode: https://github.com/d2hydro/lhm-ribasim</p>"},{"location":"#auteurs","title":"Auteurs","text":""},{"location":"#inleiding","title":"Inleiding","text":""},{"location":"get_started/","title":"Gebruikershandleiding","text":""},{"location":"get_started/#downloaden-data","title":"Downloaden data","text":"<ul> <li>Download de bestanden van Deltares-ftp in <code>path\\naar\\de\\repos\\data</code>. Zie voor de juiste structuur en beschrijving: https://github.com/d2hydro/lhm-ribasim/tree/main/data</li> </ul> <p>## Runnen test-model  - Installeer RIBASIM volgens de handleiding. Unzip de inhoud van ribasim_cli.zip in de root van de resporitory, <code>path\\naar\\de\\repos\\ribasim_cli</code>.  - Run het test-model in een cmd met <code>path\\naar\\de\\repos\\scripts\\run_test_model.cmd</code>. Dit levert het volgende resultaat:</p> <p></p> <p>## Opzetten Python environment  - Bouw je environment met https://github.com/d2hydro/lhm-ribasim/blob/main/envs/environment_dev_spyder.yml - Clone de Deltares RIBASIM repository: https://github.com/Deltares/Ribasim - Run in de geactiveerde conda-environment <code>pip install -e .</code> in de ribasim repository in de sub-folder <code>python\\ribasim</code> (je vindt daar en pyproject.toml file)</p>"},{"location":"notebooks/bouw_lhm_netwerk/","title":"Bouw LHM netwerk","text":"In\u00a0[1]: Copied! <pre>import geopandas as gpd\nimport pandas as pd\nfrom config import load_src, DATA_DIR, MOZART_DIR, LSW_DIR, LHM_DIR\nimport networkx as nx\nfrom networkx import NetworkXNoPath\nfrom networkx.classes.function import path_weight\nload_src()\nfrom lhm.read import (\n    read_lsw_routing,\n    read_dw_keys,\n    read_dm_mz_to_obese,\n    read_sobek_network_shps,\n    read_dm_network_shps,\n    read_lkm_network_links\n    )\nfrom lhm.lsw import lsw_end_nodes, lsw_network\nfrom lhm.network import merge_lsm_lkm, create_graph, Network\nfrom lhm.utils import report_progress\nfrom shapely.geometry import LineString\n</pre> import geopandas as gpd import pandas as pd from config import load_src, DATA_DIR, MOZART_DIR, LSW_DIR, LHM_DIR import networkx as nx from networkx import NetworkXNoPath from networkx.classes.function import path_weight load_src() from lhm.read import (     read_lsw_routing,     read_dw_keys,     read_dm_mz_to_obese,     read_sobek_network_shps,     read_dm_network_shps,     read_lkm_network_links     ) from lhm.lsw import lsw_end_nodes, lsw_network from lhm.network import merge_lsm_lkm, create_graph, Network from lhm.utils import report_progress from shapely.geometry import LineString In\u00a0[2]: Copied! <pre># Inlezen lsw-routing\nlsw_routing_dik = MOZART_DIR / r\"mozartin/lswrouting.dik\"\nlsw_routing_df = read_lsw_routing(lsw_routing_dik)\n\n# Inlezen en dissolven lsws\nlsw_gdf = gpd.read_file(LSW_DIR / \"lsws.shp\").dissolve(by=\"LSWFINAL\").reset_index()\n\n# bouwen lsw-netwerk\nlsw_links_gdf, lsw_nodes_gdf = lsw_network(lsw_gdf, lsw_routing_df, dissolve_lsws=False)\n</pre> # Inlezen lsw-routing lsw_routing_dik = MOZART_DIR / r\"mozartin/lswrouting.dik\" lsw_routing_df = read_lsw_routing(lsw_routing_dik)  # Inlezen en dissolven lsws lsw_gdf = gpd.read_file(LSW_DIR / \"lsws.shp\").dissolve(by=\"LSWFINAL\").reset_index()  # bouwen lsw-netwerk lsw_links_gdf, lsw_nodes_gdf = lsw_network(lsw_gdf, lsw_routing_df, dissolve_lsws=False)  In\u00a0[3]: Copied! <pre># afleiden lsw-end-nodes\nlsw_end_nodes_gdf = lsw_end_nodes(lsw_links_gdf, lsw_nodes_gdf).reset_index()\nlsw_end_nodes_gdf[\"lsw_lkm\"] = lsw_end_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\")\nlsw_end_nodes_gdf = lsw_end_nodes_gdf[[\"LSWFINAL\", \"lsw_lkm\", \"DWRN\", \"geometry\"]]\n\nlsw_nodes_gdf.reset_index(inplace=True)\nlsw_nodes_gdf[\"lsw_lkm\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\")\nlsw_nodes_gdf.set_index(\"LSWFINAL\", inplace=True)\n\nprint(f\"aantal lsw-eindknopen: {len(lsw_end_nodes_gdf)}\")\nlsw_end_nodes_gdf.explore()\n</pre> # afleiden lsw-end-nodes lsw_end_nodes_gdf = lsw_end_nodes(lsw_links_gdf, lsw_nodes_gdf).reset_index() lsw_end_nodes_gdf[\"lsw_lkm\"] = lsw_end_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\") lsw_end_nodes_gdf = lsw_end_nodes_gdf[[\"LSWFINAL\", \"lsw_lkm\", \"DWRN\", \"geometry\"]]  lsw_nodes_gdf.reset_index(inplace=True) lsw_nodes_gdf[\"lsw_lkm\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x:f\"LKM_{x}\") lsw_nodes_gdf.set_index(\"LSWFINAL\", inplace=True)  print(f\"aantal lsw-eindknopen: {len(lsw_end_nodes_gdf)}\") lsw_end_nodes_gdf.explore() <pre>aantal lsw-eindknopen: 2309\n</pre> Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre># Inlezen LSM-netwerk\nnetwork_l_gdf, network_n_gdf = read_sobek_network_shps(\n    DATA_DIR.joinpath(\"LSM_obsese\", \"LSMKRW\")\n    )\n\n# Inlezen DMMZTOSOBEKID_obese.txt\ndm_mz_to_obese_txt = DATA_DIR.joinpath(\"LSM_obsese\", \"DMMZTOSOBEKID_obese.txt\")\ndm_mz_to_obese_df = read_dm_mz_to_obese(dm_mz_to_obese_txt)\ndm_mz_to_obese_df = dm_mz_to_obese_df[\n    dm_mz_to_obese_df[\"LSM_id\"].isin(network_n_gdf.index)\n    ]\nlat_discharge_mask = dm_mz_to_obese_df[\"flow_type\"] == \"D\"\nlat_extraction_mask = dm_mz_to_obese_df[\"flow_type\"] == \"E\"\n\n# Inlezen LKM25_links.shp\nlkm25_links_shp = DATA_DIR.joinpath(\"lkm25\",\"Schematisatie\",\"KRWVerkenner\",\"shapes\",\"LKM25_Links.shp\")\nlkm25_links_gdf = read_lkm_network_links(lkm25_links_shp)\n\n# Inlezen dwkeys.txt\ndw_keys_df = read_dw_keys(DATA_DIR / r\"lhm4.3\\\\dm\\\\txtfiles_git\\\\dwkeys.txt\")\ndw_discharge_mask = dw_keys_df[\"kty\"] == \"d\"\ndw_extractions_mask = dw_keys_df[\"kty\"] == \"e\"\n\n# Inlezen DM-netwerk\ndm_links_gdf, dm_nodes_gdf = read_dm_network_shps(LHM_DIR / r\"dm/data_dvc\")\n</pre> # Inlezen LSM-netwerk network_l_gdf, network_n_gdf = read_sobek_network_shps(     DATA_DIR.joinpath(\"LSM_obsese\", \"LSMKRW\")     )  # Inlezen DMMZTOSOBEKID_obese.txt dm_mz_to_obese_txt = DATA_DIR.joinpath(\"LSM_obsese\", \"DMMZTOSOBEKID_obese.txt\") dm_mz_to_obese_df = read_dm_mz_to_obese(dm_mz_to_obese_txt) dm_mz_to_obese_df = dm_mz_to_obese_df[     dm_mz_to_obese_df[\"LSM_id\"].isin(network_n_gdf.index)     ] lat_discharge_mask = dm_mz_to_obese_df[\"flow_type\"] == \"D\" lat_extraction_mask = dm_mz_to_obese_df[\"flow_type\"] == \"E\"  # Inlezen LKM25_links.shp lkm25_links_shp = DATA_DIR.joinpath(\"lkm25\",\"Schematisatie\",\"KRWVerkenner\",\"shapes\",\"LKM25_Links.shp\") lkm25_links_gdf = read_lkm_network_links(lkm25_links_shp)  # Inlezen dwkeys.txt dw_keys_df = read_dw_keys(DATA_DIR / r\"lhm4.3\\\\dm\\\\txtfiles_git\\\\dwkeys.txt\") dw_discharge_mask = dw_keys_df[\"kty\"] == \"d\" dw_extractions_mask = dw_keys_df[\"kty\"] == \"e\"  # Inlezen DM-netwerk dm_links_gdf, dm_nodes_gdf = read_dm_network_shps(LHM_DIR / r\"dm/data_dvc\") In\u00a0[5]: Copied! <pre>import warnings\nwarnings.filterwarnings(\"ignore\")\n\n# combineren lsm-lkm netwerk\nnetwork_links_gdf, network_nodes_gdf = merge_lsm_lkm(lkm25_links_gdf, network_l_gdf, network_n_gdf)\n\nnetwork_nodes_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"nodes\")\nnetwork_links_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"links\")\n\n# afleiden netwerk-graaf\nnetwork_graph = create_graph(network_links_gdf, network_nodes_gdf)\n</pre> import warnings warnings.filterwarnings(\"ignore\")  # combineren lsm-lkm netwerk network_links_gdf, network_nodes_gdf = merge_lsm_lkm(lkm25_links_gdf, network_l_gdf, network_n_gdf)  network_nodes_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"nodes\") network_links_gdf.to_file(DATA_DIR / \"lkm-lsm-network.gpkg\", layer = \"links\")  # afleiden netwerk-graaf network_graph = create_graph(network_links_gdf, network_nodes_gdf) In\u00a0[6]: Copied! <pre>lsw_end_nodes_in_network_gdf = lsw_end_nodes_gdf[\n    lsw_end_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)\n    ]\n\nlinks = []\n\n\nnbr_groups = len(lsw_end_nodes_in_network_gdf[\"DWRN\"].unique())\nfor idx, (district, _lsw_end_nodes_df) in enumerate(lsw_end_nodes_in_network_gdf.groupby(\"DWRN\")):\n    report_progress(idx+1, nbr_groups, interval=5)\n\n    # find dm_nodes to couple with\n    \n    dm_nodes = dw_keys_df[\n        (dw_keys_df[\"oid\"] == district) &amp; dw_discharge_mask\n        ][\"nid\"].to_list()\n    \n    if not dm_nodes:\n        dm_nodes = dm_mz_to_obese_df[\n            (dm_mz_to_obese_df[\"DWRN\"] == district) &amp; lat_discharge_mask\n            ][\"DM\"].to_list()\n    \n    # find possible LSM laterals discharging to DM nodes\n    dm_mz_to_obese_select_df = dm_mz_to_obese_df[\n        dm_mz_to_obese_df[\"DM\"].isin(dm_nodes) &amp; lat_discharge_mask\n        ]\n    \n    missing_dm_links = dm_nodes\n    missing_lsw_links = []\n    \n    # couple all lsw-end-nodes to DM-node(s)\n    for row in _lsw_end_nodes_df.itertuples():\n        lsw_from = row.LSWFINAL\n        lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]\n        # find the shortest path between LSW-node and DM-node\n        for dm_to, _dm_mz_lat_df in dm_mz_to_obese_select_df.groupby(\"DM\"):\n            path_found = False\n            dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]\n            paths = []\n            path_lengths = []\n            valid_laterals = _dm_mz_lat_df[\"LSM_id\"]\n            for lateral in valid_laterals:\n                try:\n                    path = nx.shortest_path(network_graph, source=row.lsw_lkm, target=lateral, weight=\"length\", method='dijkstra')\n                    # Exclude paths that pass through other lateral nodes\n                    if all(node not in valid_laterals for node in path[1:-1]):\n                        path = [i for i in path if not i.startswith(\"LKM_\")]\n                        length = path_weight(network_graph, path, weight=\"length\")\n                        paths.append(path)\n                        path_lengths.append(length)\n                except NetworkXNoPath:\n                    continue\n            if paths:\n                path_found = True\n                path = paths[path_lengths.index(min(path_lengths))]\n                lsm_to = path[0]\n        \n                # define geometry\n                lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]\n    \n                # find idx of closest lsm-node to dm-node\n                distances = [i.distance(dm_node) for i in lsm_nodes]\n                idx = distances.index(min(distances))\n                geometry = LineString(([lsw_node] + lsm_nodes[:idx+1] + [dm_node]))\n                links += [(row.LSWFINAL, lsm_to, dm_to, district, \"discharge\", geometry)]\n                \n                missing_dm_links = [i for i in missing_dm_links if i != dm_to]\n    \n        if not path_found:\n            missing_lsw_links += [lsw_from]\n    \n    # make sure every lsw has a link to# a DM node\n    for lsw_from in missing_lsw_links:\n        lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]\n        dm_to = dm_nodes_gdf.loc[dm_nodes, \"geometry\"].distance(lsw_node).idxmin()\n        dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]\n        geometry = LineString([lsw_node, dm_node])\n        links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]\n        missing_dm_links = [i for i in missing_dm_links if i != dm_to]\n    \n    # make sure every DM #is discharged from a LSW\n    for dm_to in missing_dm_links:\n        dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]\n        lsw_from = _lsw_end_nodes_df.set_index(\"LSWFINAL\").distance(dm_node).idxmin()\n        lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]\n        geometry = LineString([lsw_node, dm_node])\n        links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]\n\nafvoer_links_gdf = gpd.GeoDataFrame(\n    data=links,\n    columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],\n    crs=28992)\n\nafvoer_links_gdf[\"node_from\"] = afvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\")\nafvoer_links_gdf[\"node_to\"] = afvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\")\nafvoer_links_gdf[\"link_type\"] = \"LSW-DM\"\nafvoer_links_gdf[\"index\"] = afvoer_links_gdf.apply(\n    (lambda x: f\"{x.node_from}-{x.node_to}\"),\n    axis=1\n    )\n</pre> lsw_end_nodes_in_network_gdf = lsw_end_nodes_gdf[     lsw_end_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)     ]  links = []   nbr_groups = len(lsw_end_nodes_in_network_gdf[\"DWRN\"].unique()) for idx, (district, _lsw_end_nodes_df) in enumerate(lsw_end_nodes_in_network_gdf.groupby(\"DWRN\")):     report_progress(idx+1, nbr_groups, interval=5)      # find dm_nodes to couple with          dm_nodes = dw_keys_df[         (dw_keys_df[\"oid\"] == district) &amp; dw_discharge_mask         ][\"nid\"].to_list()          if not dm_nodes:         dm_nodes = dm_mz_to_obese_df[             (dm_mz_to_obese_df[\"DWRN\"] == district) &amp; lat_discharge_mask             ][\"DM\"].to_list()          # find possible LSM laterals discharging to DM nodes     dm_mz_to_obese_select_df = dm_mz_to_obese_df[         dm_mz_to_obese_df[\"DM\"].isin(dm_nodes) &amp; lat_discharge_mask         ]          missing_dm_links = dm_nodes     missing_lsw_links = []          # couple all lsw-end-nodes to DM-node(s)     for row in _lsw_end_nodes_df.itertuples():         lsw_from = row.LSWFINAL         lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]         # find the shortest path between LSW-node and DM-node         for dm_to, _dm_mz_lat_df in dm_mz_to_obese_select_df.groupby(\"DM\"):             path_found = False             dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]             paths = []             path_lengths = []             valid_laterals = _dm_mz_lat_df[\"LSM_id\"]             for lateral in valid_laterals:                 try:                     path = nx.shortest_path(network_graph, source=row.lsw_lkm, target=lateral, weight=\"length\", method='dijkstra')                     # Exclude paths that pass through other lateral nodes                     if all(node not in valid_laterals for node in path[1:-1]):                         path = [i for i in path if not i.startswith(\"LKM_\")]                         length = path_weight(network_graph, path, weight=\"length\")                         paths.append(path)                         path_lengths.append(length)                 except NetworkXNoPath:                     continue             if paths:                 path_found = True                 path = paths[path_lengths.index(min(path_lengths))]                 lsm_to = path[0]                          # define geometry                 lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]                      # find idx of closest lsm-node to dm-node                 distances = [i.distance(dm_node) for i in lsm_nodes]                 idx = distances.index(min(distances))                 geometry = LineString(([lsw_node] + lsm_nodes[:idx+1] + [dm_node]))                 links += [(row.LSWFINAL, lsm_to, dm_to, district, \"discharge\", geometry)]                                  missing_dm_links = [i for i in missing_dm_links if i != dm_to]              if not path_found:             missing_lsw_links += [lsw_from]          # make sure every lsw has a link to# a DM node     for lsw_from in missing_lsw_links:         lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]         dm_to = dm_nodes_gdf.loc[dm_nodes, \"geometry\"].distance(lsw_node).idxmin()         dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]         geometry = LineString([lsw_node, dm_node])         links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]         missing_dm_links = [i for i in missing_dm_links if i != dm_to]          # make sure every DM #is discharged from a LSW     for dm_to in missing_dm_links:         dm_node = dm_nodes_gdf.at[dm_to, \"geometry\"]         lsw_from = _lsw_end_nodes_df.set_index(\"LSWFINAL\").distance(dm_node).idxmin()         lsw_node = lsw_nodes_gdf.at[lsw_from, \"geometry\"]         geometry = LineString([lsw_node, dm_node])         links += [(lsw_from, None, dm_to, district, \"discharge\", geometry)]  afvoer_links_gdf = gpd.GeoDataFrame(     data=links,     columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],     crs=28992)  afvoer_links_gdf[\"node_from\"] = afvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\") afvoer_links_gdf[\"node_to\"] = afvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\") afvoer_links_gdf[\"link_type\"] = \"LSW-DM\" afvoer_links_gdf[\"index\"] = afvoer_links_gdf.apply(     (lambda x: f\"{x.node_from}-{x.node_to}\"),     axis=1     ) <pre>[####################] 100.0% completed\r</pre> In\u00a0[7]: Copied! <pre># Graaf omzetten naar undirected\nif network_graph.is_directed():\n    network_graph = network_graph.to_undirected()\nlsw_nodes_in_network_gdf = lsw_nodes_gdf[\n    lsw_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)\n    ]\n# Zoeken naar links\nlinks = []\nnbr_groups = len(dw_keys_df[dw_extractions_mask][\"oid\"].unique())\nfor idx, (district, _extract_df) in enumerate(dw_keys_df[dw_extractions_mask].groupby(\"oid\")):\n    report_progress(idx+1, nbr_groups, interval=5)\n    #print(f\"district: {district}\")\n    dm_nodes = _extract_df[\"nid\"]\n    for dm_from in dm_nodes.values:\n        #print(f\"   dm-node: {dm_from}\")\n        dm_node = dm_nodes_gdf.at[dm_from, \"geometry\"]\n        \n        paths = []\n        path_lengths = []\n        lsws = []\n        dm_mz_to_obese_select_df = dm_mz_to_obese_df[\n            (dm_mz_to_obese_df[\"DM\"] == dm_from) &amp; lat_extraction_mask &amp; (dm_mz_to_obese_df[\"DWRN\"] == district)\n            ]\n        lsw_district_nodes_df = lsw_end_nodes_in_network_gdf[lsw_end_nodes_in_network_gdf[\"DWRN\"] == district]\n        \n        if lsw_district_nodes_df.empty:\n            lsw_district_nodes_df = lsw_nodes_in_network_gdf[lsw_nodes_in_network_gdf[\"DWRN\"] == district]\n            lsw_district_nodes_df.reset_index(inplace=True)\n            \n        if not dm_mz_to_obese_select_df.empty:\n            lsm_from = dm_mz_to_obese_select_df[\"LSM_id\"].values[0]\n            lkm_lsw_nodes = lsw_district_nodes_df[\"lsw_lkm\"]\n            for row in lsw_district_nodes_df.itertuples():\n                lsw_lkm_to = row.lsw_lkm\n                try:\n                    path = nx.shortest_path(network_graph, source=lsm_from, target=lsw_lkm_to, weight=\"length\", method='dijkstra')\n                    # Exclude paths that pass through other lateral nodes\n                    if all(node not in lkm_lsw_nodes for node in path[1:-1]):\n                        #path = [i for i in path if not i.startswith(\"LKM_\")]\n                        length = path_weight(network_graph, path, weight=\"length\")\n                        paths.append(path)\n                        path_lengths.append(length)\n                except NetworkXNoPath:\n                    continue\n        if paths:\n            idx = path_lengths.index(min(path_lengths))\n            path = paths[idx]\n            lsw_to = int(path[-1][4:])\n            path = [i for i in path if not i.startswith(\"LKM_\")]\n            lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]\n            \n            # define geometry\n            lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]\n            geometry = LineString(([dm_node] + lsm_nodes + [lsw_node]))\n            \n            links += [(lsw_to, lsm_from, dm_from, district, \"extraction\", geometry)]\n        else:\n            lsw = lsw_district_nodes_df.loc[lsw_district_nodes_df.distance(dm_node).idxmin()]\n            lsw_to = lsw.LSWFINAL\n            lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]\n            geometry = LineString([dm_node, lsw_node])\n            links += [(lsw_to, None, dm_from, district, \"extraction\", geometry)]\n\naanvoer_links_gdf = gpd.GeoDataFrame(\n                    data=links,\n                    columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],\n                    crs=28992)\n\naanvoer_links_gdf[\"node_from\"] = aanvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\")\naanvoer_links_gdf[\"node_to\"] = aanvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\")\naanvoer_links_gdf[\"link_type\"] = \"DM-LSW\"\naanvoer_links_gdf[\"index\"] = aanvoer_links_gdf.apply(\n    (lambda x: f\"{x.node_from}-{x.node_to}\"),\n    axis=1\n    )\n</pre> # Graaf omzetten naar undirected if network_graph.is_directed():     network_graph = network_graph.to_undirected() lsw_nodes_in_network_gdf = lsw_nodes_gdf[     lsw_nodes_gdf[\"lsw_lkm\"].isin(network_nodes_gdf.index)     ] # Zoeken naar links links = [] nbr_groups = len(dw_keys_df[dw_extractions_mask][\"oid\"].unique()) for idx, (district, _extract_df) in enumerate(dw_keys_df[dw_extractions_mask].groupby(\"oid\")):     report_progress(idx+1, nbr_groups, interval=5)     #print(f\"district: {district}\")     dm_nodes = _extract_df[\"nid\"]     for dm_from in dm_nodes.values:         #print(f\"   dm-node: {dm_from}\")         dm_node = dm_nodes_gdf.at[dm_from, \"geometry\"]                  paths = []         path_lengths = []         lsws = []         dm_mz_to_obese_select_df = dm_mz_to_obese_df[             (dm_mz_to_obese_df[\"DM\"] == dm_from) &amp; lat_extraction_mask &amp; (dm_mz_to_obese_df[\"DWRN\"] == district)             ]         lsw_district_nodes_df = lsw_end_nodes_in_network_gdf[lsw_end_nodes_in_network_gdf[\"DWRN\"] == district]                  if lsw_district_nodes_df.empty:             lsw_district_nodes_df = lsw_nodes_in_network_gdf[lsw_nodes_in_network_gdf[\"DWRN\"] == district]             lsw_district_nodes_df.reset_index(inplace=True)                      if not dm_mz_to_obese_select_df.empty:             lsm_from = dm_mz_to_obese_select_df[\"LSM_id\"].values[0]             lkm_lsw_nodes = lsw_district_nodes_df[\"lsw_lkm\"]             for row in lsw_district_nodes_df.itertuples():                 lsw_lkm_to = row.lsw_lkm                 try:                     path = nx.shortest_path(network_graph, source=lsm_from, target=lsw_lkm_to, weight=\"length\", method='dijkstra')                     # Exclude paths that pass through other lateral nodes                     if all(node not in lkm_lsw_nodes for node in path[1:-1]):                         #path = [i for i in path if not i.startswith(\"LKM_\")]                         length = path_weight(network_graph, path, weight=\"length\")                         paths.append(path)                         path_lengths.append(length)                 except NetworkXNoPath:                     continue         if paths:             idx = path_lengths.index(min(path_lengths))             path = paths[idx]             lsw_to = int(path[-1][4:])             path = [i for i in path if not i.startswith(\"LKM_\")]             lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]                          # define geometry             lsm_nodes = [network_nodes_gdf.at[i, \"geometry\"] for i in path]             geometry = LineString(([dm_node] + lsm_nodes + [lsw_node]))                          links += [(lsw_to, lsm_from, dm_from, district, \"extraction\", geometry)]         else:             lsw = lsw_district_nodes_df.loc[lsw_district_nodes_df.distance(dm_node).idxmin()]             lsw_to = lsw.LSWFINAL             lsw_node = lsw_nodes_gdf.at[lsw_to, \"geometry\"]             geometry = LineString([dm_node, lsw_node])             links += [(lsw_to, None, dm_from, district, \"extraction\", geometry)]  aanvoer_links_gdf = gpd.GeoDataFrame(                     data=links,                     columns=[\"lsw\",\"lsm\", \"dm\", \"dictrict\", \"flow_type\", \"geometry\"],                     crs=28992)  aanvoer_links_gdf[\"node_from\"] = aanvoer_links_gdf[\"dm\"].apply(lambda x: f\"DMnd_{x}\") aanvoer_links_gdf[\"node_to\"] = aanvoer_links_gdf[\"lsw\"].apply(lambda x: f\"MZlsw_{x}\") aanvoer_links_gdf[\"link_type\"] = \"DM-LSW\" aanvoer_links_gdf[\"index\"] = aanvoer_links_gdf.apply(     (lambda x: f\"{x.node_from}-{x.node_to}\"),     axis=1     ) <pre>[####################] 100.0% completed\r</pre> In\u00a0[8]: Copied! <pre># DM-netwerk voorbereiden\ndm_links_gdf[\"node_from\"] = dm_links_gdf[\"node_from\"].apply(lambda x: f\"DMnd_{x}\")\ndm_links_gdf[\"node_to\"] = dm_links_gdf[\"node_to\"].apply(lambda x: f\"DMnd_{x}\")\ndm_links_gdf[\"index\"] = dm_links_gdf[\"index\"].apply(lambda x: f\"DMlk_{x}\")\ndm_links_gdf[\"link_type\"] = \"DM-DM\"\ndm_nodes_gdf[\"index\"] = dm_nodes_gdf[\"index\"].apply(lambda x: f\"DMnd_{x}\")\n\n# LSW-netwerk voorbreiden\nlsw_links_gdf[\"node_from\"] = lsw_links_gdf[\"node_from\"].apply(lambda x: f\"MZlsw_{x}\")\nlsw_links_gdf[\"node_to\"] = lsw_links_gdf[\"node_to\"].apply(lambda x: f\"MZlsw_{x}\")\nlsw_links_gdf[\"index\"] = lsw_links_gdf.apply((lambda x: f\"{x.node_from}-{x.node_to}\"), axis=1)\nlsw_links_gdf[\"link_type\"] = \"LSW-LSW\"\nlsw_nodes_gdf.reset_index(inplace=True)\nlsw_nodes_gdf[\"index\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x: f\"MZlsw_{x}\")\n\n# Samenstellen netwerk-links\nlinks_gdf = pd.concat(\n    [lsw_links_gdf,\n     afvoer_links_gdf,\n     aanvoer_links_gdf,\n     dm_links_gdf]\n    )\n\n# Samenstellen netwerk-nodes\nnodes_gdf = pd.concat([lsw_nodes_gdf, dm_nodes_gdf])\n\n# aanmaken lhm-netwerk en wegschrijven\nlhm_netwerk = Network(nodes=nodes_gdf, links=links_gdf)\nlhm_netwerk.to_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\")\n\nlhm_netwerk.explore()\n</pre> # DM-netwerk voorbereiden dm_links_gdf[\"node_from\"] = dm_links_gdf[\"node_from\"].apply(lambda x: f\"DMnd_{x}\") dm_links_gdf[\"node_to\"] = dm_links_gdf[\"node_to\"].apply(lambda x: f\"DMnd_{x}\") dm_links_gdf[\"index\"] = dm_links_gdf[\"index\"].apply(lambda x: f\"DMlk_{x}\") dm_links_gdf[\"link_type\"] = \"DM-DM\" dm_nodes_gdf[\"index\"] = dm_nodes_gdf[\"index\"].apply(lambda x: f\"DMnd_{x}\")  # LSW-netwerk voorbreiden lsw_links_gdf[\"node_from\"] = lsw_links_gdf[\"node_from\"].apply(lambda x: f\"MZlsw_{x}\") lsw_links_gdf[\"node_to\"] = lsw_links_gdf[\"node_to\"].apply(lambda x: f\"MZlsw_{x}\") lsw_links_gdf[\"index\"] = lsw_links_gdf.apply((lambda x: f\"{x.node_from}-{x.node_to}\"), axis=1) lsw_links_gdf[\"link_type\"] = \"LSW-LSW\" lsw_nodes_gdf.reset_index(inplace=True) lsw_nodes_gdf[\"index\"] = lsw_nodes_gdf[\"LSWFINAL\"].apply(lambda x: f\"MZlsw_{x}\")  # Samenstellen netwerk-links links_gdf = pd.concat(     [lsw_links_gdf,      afvoer_links_gdf,      aanvoer_links_gdf,      dm_links_gdf]     )  # Samenstellen netwerk-nodes nodes_gdf = pd.concat([lsw_nodes_gdf, dm_nodes_gdf])  # aanmaken lhm-netwerk en wegschrijven lhm_netwerk = Network(nodes=nodes_gdf, links=links_gdf) lhm_netwerk.to_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\")  lhm_netwerk.explore() Out[8]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"notebooks/bouw_lhm_netwerk/#bouw-lhm-netwerk","title":"Bouw LHM netwerk\u00b6","text":"<p>Met deze Notebook leiden we het netwerk van het Landelijk Hydrologisch Model (LHM) af op basis van het Distributie Model (DM), de routing van Local Surface Water (LSW) en een routing tussen DM en LSWs, waarbij we gebruik makn van het Landelijk Sobek Model (LSM) en het Landelijke KRW verkenner model (LKM).</p> <p>Werkwijze in hoofdstukken:</p> <ol> <li>Afleiden LSW-netwerk: local service waters (lsws) waarvan een routing naar een andere lsw bekend is, routen we naar deze lsw. Dit levert tevens een lijst met <code>lsw-end-nodes</code> op, die in stap 2 aan het DM worden gekoppeld</li> <li>AFleiden LSW-DM-links: <code>lsw-end-nodes</code> worden gekoppeld aan het DM via een gecombineerd netwerk van het Landelijk KRW verkenner model (<code>LKM</code>) en het landelijk Sobek Model (<code>LSM</code>). Voor het <code>LSM</code> is een lijst bekend van lateralen die afwateren naar of aanvoeren vanuit districten en DM-knopen.</li> <li>Opbouw LHM-netwerk: het DM-netwerk nemen we over, het LSW-netwerk (<code>1</code>) en de  LSW-DM-links (<code>2</code>) worden daarmee geintegreerd.</li> </ol>"},{"location":"notebooks/bouw_lhm_netwerk/#1-lsw-netwerk","title":"1. LSW-netwerk\u00b6","text":"<p>We lezen <code>lswrouting.dik</code> (beschrijft lsw-naar-lsw-routing) en <code>lsws.shp</code>. Met de functie <code>lsw_network</code> kunnen we hier een lsw-netwerk van bouwen met <code>lsw_links_gdf</code> en <code>lsw_nodes_gdf</code>. De functie <code>lsw_end_nodes</code> levert ons lsw eindknopen op die we moeten koppelen aan het DM.</p>"},{"location":"notebooks/bouw_lhm_netwerk/#11-bouwen-lsw-netwerk","title":"1.1. Bouwen lsw-netwerk\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#12-afleiden-lsw-eindknopen","title":"1.2. Afleiden LSW-eindknopen\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#2-lsw-dm-links","title":"2. LSW-DM-links\u00b6","text":"<p>We doorlopen de volgende stappen:</p> <ol> <li>Inlezen:<ul> <li>LSM-netwerk: <code>network_l.shp</code> en <code>network_n.shp</code> met de functie <code>read_sobek_network_shps</code></li> <li><code>DMMZTOSOBEKID_obese.txt</code> met functie <code>read_dm_mz_to_obese</code></li> <li><code>LKM25_links.shp</code> met functie <code>read_lkm_network_links</code></li> <li><code>dwkeys.txt</code> met functie <code>read_dw_keys</code></li> <li>DM-netwerk met <code>read_dm_network_shps</code></li> </ul> </li> <li>Bouwen van lkm-lsm netwerk bestanden met functie <code>merge_lsm_lkm</code> en omzetten naar een netwerk-graaf</li> <li>Afleiden afvoerlinks uit de graaf</li> <li>Afleiden van aanvoerlinks uit de graaf</li> </ol>"},{"location":"notebooks/bouw_lhm_netwerk/#21-inlezen","title":"2.1. Inlezen\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#22-bouwen-lsm-lkm-netwerk-graaf","title":"2.2. Bouwen LSM-LKM netwerk + graaf\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#23-afleiden-afvoerlinks","title":"2.3 Afleiden afvoerlinks\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#24-afleiden-aanvoerlinks","title":"2.4 Afleiden aanvoerlinks\u00b6","text":""},{"location":"notebooks/bouw_lhm_netwerk/#3-opbouw-lhm-netwerk","title":"3. Opbouw LHM-netwerk\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/","title":"Bouw Ribasim schematisatie","text":"In\u00a0[1]: Copied! <pre>from config import LHM_DIR, DATA_DIR, MODEL_DIR, load_src\nimport geopandas as gpd\nimport pandas as pd\nimport xarray as xr\nfrom shapely.geometry import Point, LineString\nimport ribasim\nload_src()\n\nfrom lhm.network import Network\nfrom lhm.utils import next_index\nfrom lhm.read import read_dm_nds\nfrom lhm.utils import report_progress\n</pre> from config import LHM_DIR, DATA_DIR, MODEL_DIR, load_src import geopandas as gpd import pandas as pd import xarray as xr from shapely.geometry import Point, LineString import ribasim load_src()  from lhm.network import Network from lhm.utils import next_index from lhm.read import read_dm_nds from lhm.utils import report_progress In\u00a0[2]: Copied! <pre>model_name=\"ribasim_model_flevoland\"\nmask_gdf = gpd.read_file(DATA_DIR / \"mask.gpkg\")\nmask_poly = mask_gdf.iloc[0].geometry\nbbox = mask_poly.bounds\n#bbox = None\n</pre> model_name=\"ribasim_model_flevoland\" mask_gdf = gpd.read_file(DATA_DIR / \"mask.gpkg\") mask_poly = mask_gdf.iloc[0].geometry bbox = mask_poly.bounds #bbox = None In\u00a0[3]: Copied! <pre>lhm_netwerk = Network.from_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\", bbox=bbox)\nlhm_netwerk.to_gpkg(DATA_DIR/ f\"lhm_{model_name}.gpkg\")\nlhm_netwerk.explore()\n</pre> lhm_netwerk = Network.from_gpkg(DATA_DIR / \"lhm-netwerk.gpkg\", bbox=bbox) lhm_netwerk.to_gpkg(DATA_DIR/ f\"lhm_{model_name}.gpkg\") lhm_netwerk.explore() Out[3]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[4]: Copied! <pre># Inlezen knopen uit netwerk en simplied mozart SAQH tables\nnodes_gdf = lhm_netwerk.nodes.copy()\ninput_mozart_ds = xr.open_dataset(DATA_DIR / r\"ribasim_testmodel/simplified_SAQh.nc\")\n\n# knopen filteren op beschikbare data in mozart simplified\nlsw_nodes_mask = nodes_gdf[\"index\"].str.startswith(\"MZlsw_\")\nlsw_table_indices =[f\"MZlsw_{i}\" for i in input_mozart_ds[\"node\"].values.astype(int)]\nnodes_gdf = nodes_gdf[~lsw_nodes_mask | nodes_gdf[\"index\"].isin(lsw_table_indices)]\nnodes_gdf[\"lhm_index\"] = nodes_gdf[\"index\"]\nnodes_gdf[\"type\"] = \"Basin\"\n\nnodes_gdf.reset_index(inplace=True, drop=True)\nnodes_gdf.index = nodes_gdf.index + 1\nnodes_gdf[\"index\"] = nodes_gdf.index\n# tonen aan de gebruiker\nnodes_gdf\n</pre> # Inlezen knopen uit netwerk en simplied mozart SAQH tables nodes_gdf = lhm_netwerk.nodes.copy() input_mozart_ds = xr.open_dataset(DATA_DIR / r\"ribasim_testmodel/simplified_SAQh.nc\")  # knopen filteren op beschikbare data in mozart simplified lsw_nodes_mask = nodes_gdf[\"index\"].str.startswith(\"MZlsw_\") lsw_table_indices =[f\"MZlsw_{i}\" for i in input_mozart_ds[\"node\"].values.astype(int)] nodes_gdf = nodes_gdf[~lsw_nodes_mask | nodes_gdf[\"index\"].isin(lsw_table_indices)] nodes_gdf[\"lhm_index\"] = nodes_gdf[\"index\"] nodes_gdf[\"type\"] = \"Basin\"  nodes_gdf.reset_index(inplace=True, drop=True) nodes_gdf.index = nodes_gdf.index + 1 nodes_gdf[\"index\"] = nodes_gdf.index # tonen aan de gebruiker nodes_gdf Out[4]: index geometry lhm_index type 1 1 POINT (140573.890 476409.651) MZlsw_21013 Basin 2 2 POINT (142103.697 476901.516) MZlsw_21011 Basin 3 3 POINT (138645.749 477151.537) MZlsw_21012 Basin 4 4 POINT (144905.649 477910.142) MZlsw_21010 Basin 5 5 POINT (142435.955 478818.415) MZlsw_21006 Basin ... ... ... ... ... 134 134 POINT (179324.333 504346.375) MZlsw_260077 Basin 135 135 POINT (177279.558 504319.119) MZlsw_260078 Basin 136 136 POINT (174454.178 507388.300) MZlsw_260094 Basin 137 137 POINT (176609.670 510253.423) MZlsw_260093 Basin 138 138 POINT (172140.739 512527.561) MZlsw_260099 Basin <p>138 rows \u00d7 4 columns</p> In\u00a0[5]: Copied! <pre># tabellen toevoegen\nda = input_mozart_ds.profile.transpose(\"node\", \"profile_col\", \"profile_row\")\nlsw_basin_profiles_df = pd.DataFrame(\n        [item.T for sublist in da.values for item in sublist.T],\n        columns = [\"storage\", \"area\",\"discharge\", \"level\"]\n        )\nlsw_basin_profiles_df[\"lhm_index\"] = [f\"MZlsw_{str(int(x))}\" for x in da.node.values for _ in range(4)]\nlsw_basin_profiles_df[\"remarks\"] = \"uit simplified_SAQh.nc\"\n\nlsw_basin_profiles_df = lsw_basin_profiles_df[lsw_basin_profiles_df[\"lhm_index\"].isin(nodes_gdf[\"lhm_index\"])]\n\nlsw_basin_profiles_df\n</pre> # tabellen toevoegen da = input_mozart_ds.profile.transpose(\"node\", \"profile_col\", \"profile_row\") lsw_basin_profiles_df = pd.DataFrame(         [item.T for sublist in da.values for item in sublist.T],         columns = [\"storage\", \"area\",\"discharge\", \"level\"]         ) lsw_basin_profiles_df[\"lhm_index\"] = [f\"MZlsw_{str(int(x))}\" for x in da.node.values for _ in range(4)] lsw_basin_profiles_df[\"remarks\"] = \"uit simplified_SAQh.nc\"  lsw_basin_profiles_df = lsw_basin_profiles_df[lsw_basin_profiles_df[\"lhm_index\"].isin(nodes_gdf[\"lhm_index\"])]  lsw_basin_profiles_df Out[5]: storage area discharge level lhm_index remarks 2348 0.000000 68056.046875 0.000000 -1.566615 MZlsw_20024 uit simplified_SAQh.nc 2349 9365.777344 68056.046875 0.000000 -1.366615 MZlsw_20024 uit simplified_SAQh.nc 2350 18731.554688 68056.046875 0.024826 -1.166615 MZlsw_20024 uit simplified_SAQh.nc 2351 945943.500000 68056.046875 2.482551 18.633385 MZlsw_20024 uit simplified_SAQh.nc 2352 0.000000 47411.921875 0.000000 -0.968000 MZlsw_20025 uit simplified_SAQh.nc ... ... ... ... ... ... ... 31655 852750.562500 47374.812500 1.131316 14.410000 MZlsw_260115 uit simplified_SAQh.nc 31656 0.000000 9373.941406 0.000000 -4.593889 MZlsw_260116 uit simplified_SAQh.nc 31657 1344.484253 9373.941406 0.000000 -4.393889 MZlsw_260116 uit simplified_SAQh.nc 31658 2688.968506 9373.941406 0.015075 -4.193889 MZlsw_260116 uit simplified_SAQh.nc 31659 135792.906250 9373.941406 1.507501 15.606111 MZlsw_260116 uit simplified_SAQh.nc <p>524 rows \u00d7 6 columns</p> In\u00a0[6]: Copied! <pre># % uit DM nds file\ndef default_profile():\n    return pd.DataFrame(\n        data = [[-5, 0 ,0, None], [5, 1000000 , 10000000, None]],\n        columns= [\"level\", \"area\", \"storage\", \"remarks\"]\n        )\n\ndef lav(row):\n    dm_id = row.lhm_index[5:]\n    if dm_id not in dm_nds_df.index:\n        profile = default_profile()\n        profile[\"remarks\"] = \"default-profile\"\n    else:\n        node_row = dm_nds_df.loc[dm_id]\n        if node_row.lav is None:\n            profile = default_profile()\n            remarks = []\n            if not (node_row.ar == 0.):\n                if not pd.isna(node_row.ar):\n                    profile[\"area\"] = node_row.ar\n                    remarks += [\"constant area\" ]\n            if not (node_row.vo == 0.):\n                if not pd.isna(node_row.vo):\n                    profile[\"storage\"] = node_row.vo\n                    remarks += [\"constant volume\"]\n            if remarks:\n                profile[\"remarks\"] = \",\".join(remarks)\n            else:\n                profile[\"remarks\"] = \"default-profile\"\n        else:\n            profile = node_row.lav.copy(deep=True)\n            profile.index.name= \"level\"\n            profile.reset_index(inplace=True)\n            profile[\"remarks\"] = \"uit dm nds.txt\"\n    profile[\"lhm_index\"] = f\"{row.lhm_index}\"\n    return profile\n\ndm_nds_df = read_dm_nds(LHM_DIR / r\"dm/txtfiles_git/nds.txt\").set_index(\"id\")\ndm_nodes_gdf = nodes_gdf[nodes_gdf[\"lhm_index\"].str.startswith(\"DMnd_\")]\ndm_basin_profiles_df = pd.concat([lav(row) for row in dm_nodes_gdf.itertuples()]).reset_index(drop=True)\ndm_basin_profiles_df\n</pre> # % uit DM nds file def default_profile():     return pd.DataFrame(         data = [[-5, 0 ,0, None], [5, 1000000 , 10000000, None]],         columns= [\"level\", \"area\", \"storage\", \"remarks\"]         )  def lav(row):     dm_id = row.lhm_index[5:]     if dm_id not in dm_nds_df.index:         profile = default_profile()         profile[\"remarks\"] = \"default-profile\"     else:         node_row = dm_nds_df.loc[dm_id]         if node_row.lav is None:             profile = default_profile()             remarks = []             if not (node_row.ar == 0.):                 if not pd.isna(node_row.ar):                     profile[\"area\"] = node_row.ar                     remarks += [\"constant area\" ]             if not (node_row.vo == 0.):                 if not pd.isna(node_row.vo):                     profile[\"storage\"] = node_row.vo                     remarks += [\"constant volume\"]             if remarks:                 profile[\"remarks\"] = \",\".join(remarks)             else:                 profile[\"remarks\"] = \"default-profile\"         else:             profile = node_row.lav.copy(deep=True)             profile.index.name= \"level\"             profile.reset_index(inplace=True)             profile[\"remarks\"] = \"uit dm nds.txt\"     profile[\"lhm_index\"] = f\"{row.lhm_index}\"     return profile  dm_nds_df = read_dm_nds(LHM_DIR / r\"dm/txtfiles_git/nds.txt\").set_index(\"id\") dm_nodes_gdf = nodes_gdf[nodes_gdf[\"lhm_index\"].str.startswith(\"DMnd_\")] dm_basin_profiles_df = pd.concat([lav(row) for row in dm_nodes_gdf.itertuples()]).reset_index(drop=True) dm_basin_profiles_df Out[6]: level area storage remarks lhm_index 0 -5 0.0 0.000000e+00 default-profile DMnd_591 1 5 1000000.0 1.000000e+07 default-profile DMnd_591 2 -5 0.0 0.000000e+00 default-profile DMnd_592 3 5 1000000.0 1.000000e+07 default-profile DMnd_592 4 -1.0 660600000.0 2.001700e+09 uit dm nds.txt DMnd_6058 5 -0.6 660600000.0 2.266000e+09 uit dm nds.txt DMnd_6058 6 -0.25 660600000.0 2.497200e+09 uit dm nds.txt DMnd_6058 7 0.25 660600000.0 2.827500e+09 uit dm nds.txt DMnd_6058 8 1.00 660600000.0 3.322900e+09 uit dm nds.txt DMnd_6058 9 -5 0.0 0.000000e+00 default-profile DMnd_6058_1 10 5 1000000.0 1.000000e+07 default-profile DMnd_6058_1 11 -1.0 73500000.0 2.227000e+08 uit dm nds.txt DMnd_60581 12 -0.6 73500000.0 2.520000e+08 uit dm nds.txt DMnd_60581 13 -0.25 73500000.0 2.778000e+08 uit dm nds.txt DMnd_60581 14 0.25 73500000.0 3.145000e+08 uit dm nds.txt DMnd_60581 15 1.00 73500000.0 3.697000e+08 uit dm nds.txt DMnd_60581 16 -1.0 62700000.0 3.225000e+07 uit dm nds.txt DMnd_6059 17 -0.6 62700000.0 5.733000e+07 uit dm nds.txt DMnd_6059 18 -0.1 62700000.0 8.868000e+07 uit dm nds.txt DMnd_6059 19 0.40 62700000.0 1.200000e+08 uit dm nds.txt DMnd_6059 20 1.00 62700000.0 1.576000e+08 uit dm nds.txt DMnd_6059 21 -5 0.0 0.000000e+00 default-profile DMnd_6059_1 22 5 1000000.0 1.000000e+07 default-profile DMnd_6059_1 In\u00a0[7]: Copied! <pre># Samenvoegen\nbasin_profiles_gdf = gpd.GeoDataFrame(\n    pd.concat(\n        [lsw_basin_profiles_df,\n         dm_basin_profiles_df],\n        ignore_index=True\n    ),\n    geometry=gpd.GeoSeries(),\n    crs=28992\n)\n\n# DataType goed zetten\nbasin_profiles_gdf[\"level\"] = basin_profiles_gdf[\"level\"].astype(float)\n\nbasin_profiles_gdf[\"node_id\"] = basin_profiles_gdf[\"lhm_index\"].apply(lambda x: nodes_gdf[nodes_gdf[\"lhm_index\"] == x].index.values[0])\n\n# Tonen aan gebruiker\nbasin_profiles_gdf\n</pre> # Samenvoegen basin_profiles_gdf = gpd.GeoDataFrame(     pd.concat(         [lsw_basin_profiles_df,          dm_basin_profiles_df],         ignore_index=True     ),     geometry=gpd.GeoSeries(),     crs=28992 )  # DataType goed zetten basin_profiles_gdf[\"level\"] = basin_profiles_gdf[\"level\"].astype(float)  basin_profiles_gdf[\"node_id\"] = basin_profiles_gdf[\"lhm_index\"].apply(lambda x: nodes_gdf[nodes_gdf[\"lhm_index\"] == x].index.values[0])  # Tonen aan gebruiker basin_profiles_gdf Out[7]: storage area discharge level lhm_index remarks geometry node_id 0 0.000000e+00 6.805605e+04 0.000000 -1.566615 MZlsw_20024 uit simplified_SAQh.nc None 27 1 9.365777e+03 6.805605e+04 0.000000 -1.366615 MZlsw_20024 uit simplified_SAQh.nc None 27 2 1.873155e+04 6.805605e+04 0.024826 -1.166615 MZlsw_20024 uit simplified_SAQh.nc None 27 3 9.459435e+05 6.805605e+04 2.482551 18.633385 MZlsw_20024 uit simplified_SAQh.nc None 27 4 0.000000e+00 4.741192e+04 0.000000 -0.968000 MZlsw_20025 uit simplified_SAQh.nc None 7 ... ... ... ... ... ... ... ... ... 542 8.868000e+07 6.270000e+07 NaN -0.100000 DMnd_6059 uit dm nds.txt None 121 543 1.200000e+08 6.270000e+07 NaN 0.400000 DMnd_6059 uit dm nds.txt None 121 544 1.576000e+08 6.270000e+07 NaN 1.000000 DMnd_6059 uit dm nds.txt None 121 545 0.000000e+00 0.000000e+00 NaN -5.000000 DMnd_6059_1 default-profile None 122 546 1.000000e+07 1.000000e+06 NaN 5.000000 DMnd_6059_1 default-profile None 122 <p>547 rows \u00d7 8 columns</p> In\u00a0[8]: Copied! <pre>links_gdf = lhm_netwerk.links.copy()\nlinks_gdf = links_gdf[links_gdf[\"node_from\"].isin(nodes_gdf[\"lhm_index\"]) &amp; links_gdf[\"node_to\"].isin(nodes_gdf[\"lhm_index\"])]\n\npassed_indexes = []\ntabulated_profiles_df = pd.DataFrame(columns=[\"lhm_index\", \"level\", \"discharge\", \"remarks\", \"node_id\"])\nnodes = []\nedges = []\nmanning_resistance = []\nfractional_flow = []\nlhm_nodes_gdf = nodes_gdf.reset_index().set_index(\"lhm_index\")\nlhm_indices = {v:k for k,v in nodes_gdf[\"lhm_index\"].to_dict().items()}\n\ndef get_flow_point(geometries, node_type):\n    \n    if len(geometries) &gt; 1:\n        point = geometries.iloc[0].boundary.geoms[0]\n        point = Point(point.x, point.y - 100)\n    elif node_type == \"TabulatedRatingCurve\":\n        line = geometries.iloc[0]\n        point = line.interpolate(min(100, line.length / 2))\n    else:\n        line = geometries.iloc[0]\n        point = line.centroid\n    return point\n\nnbr_groups = len(list(links_gdf.groupby(\"node_from\")))\nfor idx, (lhm_id, df) in enumerate(links_gdf.groupby(\"node_from\")):\n    report_progress(idx+1, nbr_groups, interval=5, print_at_interval=True)\n    if lhm_id in lhm_nodes_gdf.index:\n        #print(f\"links vanaf {lhm_id}\")\n\n        # inlezen van de eigenschappen van de start-knoop\n        node_from = lhm_nodes_gdf.loc[lhm_id]\n    \n        # Als er een QH-relatie is, dan pakken we die\n        if lhm_id in lsw_table_indices:\n            \n            # we make sure we get a new, available index.\n            tr_index = next_index(list(lhm_indices.values()))\n            lhm_indices[f\"tr_{tr_index}\"] = tr_index\n            \n            # we add the node\n            node_type = \"TabulatedRatingCurve\"\n            tr_point = get_flow_point(df.geometry, node_type)\n            nodes += [(tr_index, lhm_id, node_type, tr_point)]\n    \n            # we add the profile\n            prof_df = basin_profiles_gdf[basin_profiles_gdf[\"lhm_index\"] == lhm_id][[\"level\",\"discharge\"]]\n            prof_df[\"lhm_id\"] = lhm_id\n            prof_df[\"node_id\"] = int(tr_index)\n            tabulated_profiles_df = pd.concat([tabulated_profiles_df, prof_df])\n            # we define a edge between the upstream node and \n            edges += [(node_from[\"index\"], tr_index, LineString([node_from.geometry, tr_point]))]\n        else: # we don't need an extra node\n            node_type = \"ManningResistance\"\n    \n        # add fraction or manning nodes\n        if len(df) &gt; 1:\n            fraction = 1 / len(df)\n        for row in df.itertuples():\n            # we get, or make a node_to index\n            node_to = lhm_nodes_gdf.loc[row.node_to]\n            to_index = node_to[\"index\"]\n    \n            if node_type == \"TabulatedRatingCurve\":\n                if len(df) &gt; 1:\n                    frac_point = row.geometry.centroid\n                    frac_index = next_index(list(lhm_indices.values()))\n                    lhm_indices[f\"frac_{frac_index}\"] = frac_index\n                    nodes += [(frac_index, lhm_id, \"FractionalFlow\", frac_point)]\n                    fractional_flow += [(frac_index, fraction)]\n                    edges += [\n                        (tr_index, frac_index, LineString([tr_point, frac_point])),\n                        (frac_index, to_index, LineString([frac_point, node_to.geometry]))\n                        ]\n                else:\n                    edges += [(tr_index, to_index, LineString([tr_point, node_to.geometry]))]\n            else:\n                manning_point = row.geometry.centroid\n                manning_index = next_index(list(lhm_indices.values()))\n                lhm_indices[f\"manning_{manning_index}\"] = manning_index\n                nodes += [(manning_index, lhm_id, \"ManningResistance\", manning_point)]\n                manning_resistance += [(manning_index, 1000,0.04,50,2)]\n                edges += [\n                    (node_from[\"index\"], manning_index, LineString([node_from.geometry, manning_point])),\n                    (manning_index, to_index, LineString([manning_point, node_to.geometry]))\n                    ]\n\ntabulated_profiles_df[\"remarks\"] = \"uit simplified_SAQh.nc\"        \n\nnodes_gdf = pd.concat(\n    [nodes_gdf,\n     gpd.GeoDataFrame(\n         nodes,\n         columns=[\"index\",\"lhm_index\",\"type\",\"geometry\"],\n         crs=28992\n         ).set_index(\"index\")]\n    )\nedges_gdf = gpd.GeoDataFrame(edges, columns=[\"from_node_id\",\"to_node_id\",\"geometry\"], crs=28992)\n</pre> links_gdf = lhm_netwerk.links.copy() links_gdf = links_gdf[links_gdf[\"node_from\"].isin(nodes_gdf[\"lhm_index\"]) &amp; links_gdf[\"node_to\"].isin(nodes_gdf[\"lhm_index\"])]  passed_indexes = [] tabulated_profiles_df = pd.DataFrame(columns=[\"lhm_index\", \"level\", \"discharge\", \"remarks\", \"node_id\"]) nodes = [] edges = [] manning_resistance = [] fractional_flow = [] lhm_nodes_gdf = nodes_gdf.reset_index().set_index(\"lhm_index\") lhm_indices = {v:k for k,v in nodes_gdf[\"lhm_index\"].to_dict().items()}  def get_flow_point(geometries, node_type):          if len(geometries) &gt; 1:         point = geometries.iloc[0].boundary.geoms[0]         point = Point(point.x, point.y - 100)     elif node_type == \"TabulatedRatingCurve\":         line = geometries.iloc[0]         point = line.interpolate(min(100, line.length / 2))     else:         line = geometries.iloc[0]         point = line.centroid     return point  nbr_groups = len(list(links_gdf.groupby(\"node_from\"))) for idx, (lhm_id, df) in enumerate(links_gdf.groupby(\"node_from\")):     report_progress(idx+1, nbr_groups, interval=5, print_at_interval=True)     if lhm_id in lhm_nodes_gdf.index:         #print(f\"links vanaf {lhm_id}\")          # inlezen van de eigenschappen van de start-knoop         node_from = lhm_nodes_gdf.loc[lhm_id]              # Als er een QH-relatie is, dan pakken we die         if lhm_id in lsw_table_indices:                          # we make sure we get a new, available index.             tr_index = next_index(list(lhm_indices.values()))             lhm_indices[f\"tr_{tr_index}\"] = tr_index                          # we add the node             node_type = \"TabulatedRatingCurve\"             tr_point = get_flow_point(df.geometry, node_type)             nodes += [(tr_index, lhm_id, node_type, tr_point)]                  # we add the profile             prof_df = basin_profiles_gdf[basin_profiles_gdf[\"lhm_index\"] == lhm_id][[\"level\",\"discharge\"]]             prof_df[\"lhm_id\"] = lhm_id             prof_df[\"node_id\"] = int(tr_index)             tabulated_profiles_df = pd.concat([tabulated_profiles_df, prof_df])             # we define a edge between the upstream node and              edges += [(node_from[\"index\"], tr_index, LineString([node_from.geometry, tr_point]))]         else: # we don't need an extra node             node_type = \"ManningResistance\"              # add fraction or manning nodes         if len(df) &gt; 1:             fraction = 1 / len(df)         for row in df.itertuples():             # we get, or make a node_to index             node_to = lhm_nodes_gdf.loc[row.node_to]             to_index = node_to[\"index\"]                  if node_type == \"TabulatedRatingCurve\":                 if len(df) &gt; 1:                     frac_point = row.geometry.centroid                     frac_index = next_index(list(lhm_indices.values()))                     lhm_indices[f\"frac_{frac_index}\"] = frac_index                     nodes += [(frac_index, lhm_id, \"FractionalFlow\", frac_point)]                     fractional_flow += [(frac_index, fraction)]                     edges += [                         (tr_index, frac_index, LineString([tr_point, frac_point])),                         (frac_index, to_index, LineString([frac_point, node_to.geometry]))                         ]                 else:                     edges += [(tr_index, to_index, LineString([tr_point, node_to.geometry]))]             else:                 manning_point = row.geometry.centroid                 manning_index = next_index(list(lhm_indices.values()))                 lhm_indices[f\"manning_{manning_index}\"] = manning_index                 nodes += [(manning_index, lhm_id, \"ManningResistance\", manning_point)]                 manning_resistance += [(manning_index, 1000,0.04,50,2)]                 edges += [                     (node_from[\"index\"], manning_index, LineString([node_from.geometry, manning_point])),                     (manning_index, to_index, LineString([manning_point, node_to.geometry]))                     ]  tabulated_profiles_df[\"remarks\"] = \"uit simplified_SAQh.nc\"          nodes_gdf = pd.concat(     [nodes_gdf,      gpd.GeoDataFrame(          nodes,          columns=[\"index\",\"lhm_index\",\"type\",\"geometry\"],          crs=28992          ).set_index(\"index\")]     ) edges_gdf = gpd.GeoDataFrame(edges, columns=[\"from_node_id\",\"to_node_id\",\"geometry\"], crs=28992) <pre>[####################] 100.0% completed\r</pre> In\u00a0[9]: Copied! <pre>level_boundary = []\nlinear_resistance = []\nnodes= []\nedges = []\nlevel_boundary_mask  = nodes_gdf.index.isin(edges_gdf.to_node_id) &amp; ~nodes_gdf.index.isin(edges_gdf.from_node_id)\nfor row in nodes_gdf.loc[level_boundary_mask].itertuples():\n    resist_point = Point(row.geometry.x, row.geometry.y + 50)\n    resist_index = next_index(list(lhm_indices.values()))\n    lhm_indices[f\"resist_{resist_index}\"] = resist_index\n    bnd_point = Point(row.geometry.x, row.geometry.y + 100)\n    bnd_index = next_index(list(lhm_indices.values()))\n    lhm_indices[f\"bnd_{bnd_index}\"] = bnd_index\n    nodes += [\n        (resist_index, lhm_id, \"LinearResistance\", resist_point),\n        (bnd_index, lhm_id, \"LevelBoundary\", bnd_point)\n        ]\n    edges += [\n        (row.Index, resist_index, LineString([row.geometry, resist_point])),\n        (resist_index, bnd_index, LineString([resist_point, bnd_point]))\n        ]\n    level_boundary += [(bnd_index, -0.01)]\n    linear_resistance += [(resist_index, 5000)]\n\nnodes_gdf = pd.concat(\n    [nodes_gdf,\n      gpd.GeoDataFrame(\n          nodes,\n          columns=[\"index\",\"origin\",\"type\",\"geometry\"],\n          crs=28992\n          ).set_index(\"index\")]\n    )\n\nedges_gdf = pd.concat(\n    [edges_gdf,\n      gpd.GeoDataFrame(\n          edges,\n          columns=[\"from_node_id\",\"to_node_id\",\"geometry\"],\n          crs=28992)]\n      )\n\nedges_gdf[\"edge_type\"] = \"flow\"\n</pre> level_boundary = [] linear_resistance = [] nodes= [] edges = [] level_boundary_mask  = nodes_gdf.index.isin(edges_gdf.to_node_id) &amp; ~nodes_gdf.index.isin(edges_gdf.from_node_id) for row in nodes_gdf.loc[level_boundary_mask].itertuples():     resist_point = Point(row.geometry.x, row.geometry.y + 50)     resist_index = next_index(list(lhm_indices.values()))     lhm_indices[f\"resist_{resist_index}\"] = resist_index     bnd_point = Point(row.geometry.x, row.geometry.y + 100)     bnd_index = next_index(list(lhm_indices.values()))     lhm_indices[f\"bnd_{bnd_index}\"] = bnd_index     nodes += [         (resist_index, lhm_id, \"LinearResistance\", resist_point),         (bnd_index, lhm_id, \"LevelBoundary\", bnd_point)         ]     edges += [         (row.Index, resist_index, LineString([row.geometry, resist_point])),         (resist_index, bnd_index, LineString([resist_point, bnd_point]))         ]     level_boundary += [(bnd_index, -0.01)]     linear_resistance += [(resist_index, 5000)]  nodes_gdf = pd.concat(     [nodes_gdf,       gpd.GeoDataFrame(           nodes,           columns=[\"index\",\"origin\",\"type\",\"geometry\"],           crs=28992           ).set_index(\"index\")]     )  edges_gdf = pd.concat(     [edges_gdf,       gpd.GeoDataFrame(           edges,           columns=[\"from_node_id\",\"to_node_id\",\"geometry\"],           crs=28992)]       )  edges_gdf[\"edge_type\"] = \"flow\" In\u00a0[10]: Copied! <pre>ribasim_node = ribasim.Node(static=nodes_gdf[['lhm_index', 'geometry', 'type']])\nribasim_edge = ribasim.Edge(static=edges_gdf)\n\n# 2 mm/d precipitation, 1 mm/d evaporation\nseconds_in_day = 24 * 3600\nprecipitation = 0.002 / seconds_in_day\nevaporation = 0.001 / seconds_in_day\n\nstatic_df = pd.DataFrame(nodes_gdf[nodes_gdf[\"type\"] == \"Basin\"].reset_index()[\"index\"].values, columns=[\"node_id\"])\nstatic_df[\"drainage\"] = 0.0\nstatic_df[\"potential_evaporation\"] = evaporation\nstatic_df[\"infiltration\"] = 0.0\nstatic_df[\"precipitation\"] = precipitation\nstatic_df[\"urban_runoff\"] = 0.0\nstatic_df[\"target_level\"] = None\n\nribasim_basin = ribasim.Basin(\n    profile=basin_profiles_gdf,\n    static=static_df\n        )\nribasim_rating_curve = ribasim.TabulatedRatingCurve(static=tabulated_profiles_df)\nribasim_fractional_flow = ribasim.FractionalFlow(\n    static=pd.DataFrame(fractional_flow, columns=[\"node_id\", \"fraction\"])\n    )\nribasim_manning_resistance = ribasim.ManningResistance(\n    static=pd.DataFrame(manning_resistance,columns=[\"node_id\",\"length\",\"manning_n\",\"profile_width\",\"profile_slope\"])\n    )\n\nribasim_flow_boundary = None\nribasim_level_boundary = ribasim.LevelBoundary(\n    static=pd.DataFrame(\n        level_boundary,\n        columns=[\"node_id\", \"level\"]\n        )\n    )\n\nribasim_linear_resistance = ribasim.LinearResistance(\n    static=pd.DataFrame(\n        linear_resistance,\n        columns=[\"node_id\", \"resistance\"]\n        )\n    )\n\nmodel = ribasim.Model(\n    modelname=model_name,\n    node=ribasim_node,\n    edge=ribasim_edge,\n    basin=ribasim_basin,\n    level_boundary=ribasim_level_boundary,\n    flow_boundary=ribasim_flow_boundary,\n    manning_resistance=ribasim_manning_resistance,\n    linear_resistance=ribasim_linear_resistance,\n    tabulated_rating_curve=ribasim_rating_curve,\n    fractional_flow=ribasim_fractional_flow,\n    starttime=\"2020-01-01 00:00:00\",\n    endtime=\"2021-01-01 00:00:00\",\n)\n\nmodel.write(MODEL_DIR / model_name)\n</pre> ribasim_node = ribasim.Node(static=nodes_gdf[['lhm_index', 'geometry', 'type']]) ribasim_edge = ribasim.Edge(static=edges_gdf)  # 2 mm/d precipitation, 1 mm/d evaporation seconds_in_day = 24 * 3600 precipitation = 0.002 / seconds_in_day evaporation = 0.001 / seconds_in_day  static_df = pd.DataFrame(nodes_gdf[nodes_gdf[\"type\"] == \"Basin\"].reset_index()[\"index\"].values, columns=[\"node_id\"]) static_df[\"drainage\"] = 0.0 static_df[\"potential_evaporation\"] = evaporation static_df[\"infiltration\"] = 0.0 static_df[\"precipitation\"] = precipitation static_df[\"urban_runoff\"] = 0.0 static_df[\"target_level\"] = None  ribasim_basin = ribasim.Basin(     profile=basin_profiles_gdf,     static=static_df         ) ribasim_rating_curve = ribasim.TabulatedRatingCurve(static=tabulated_profiles_df) ribasim_fractional_flow = ribasim.FractionalFlow(     static=pd.DataFrame(fractional_flow, columns=[\"node_id\", \"fraction\"])     ) ribasim_manning_resistance = ribasim.ManningResistance(     static=pd.DataFrame(manning_resistance,columns=[\"node_id\",\"length\",\"manning_n\",\"profile_width\",\"profile_slope\"])     )  ribasim_flow_boundary = None ribasim_level_boundary = ribasim.LevelBoundary(     static=pd.DataFrame(         level_boundary,         columns=[\"node_id\", \"level\"]         )     )  ribasim_linear_resistance = ribasim.LinearResistance(     static=pd.DataFrame(         linear_resistance,         columns=[\"node_id\", \"resistance\"]         )     )  model = ribasim.Model(     modelname=model_name,     node=ribasim_node,     edge=ribasim_edge,     basin=ribasim_basin,     level_boundary=ribasim_level_boundary,     flow_boundary=ribasim_flow_boundary,     manning_resistance=ribasim_manning_resistance,     linear_resistance=ribasim_linear_resistance,     tabulated_rating_curve=ribasim_rating_curve,     fractional_flow=ribasim_fractional_flow,     starttime=\"2020-01-01 00:00:00\",     endtime=\"2021-01-01 00:00:00\", )  model.write(MODEL_DIR / model_name)"},{"location":"notebooks/bouw_ribasim_schematisatie/#bouw-ribasim-schematisatie","title":"Bouw Ribasim schematisatie\u00b6","text":"<p>Met deze Notebook bouwen we een Ribasim schematisatie op basis van het netwerk van het Landelijk Hydrologisch Model (LHM).</p> <p>De werkwijze vastgelegd in hoofdstukken:</p> <ol> <li>Inlezen van LSW en DM knopen, en profielen, als Ribasim Basins</li> <li>Het bouwen van het Ribasim netwerk (nodes en edges) tussen Ribasim Basins</li> <li>Het leggen van boundaries aan de rand van het Ribasim netwerk</li> <li>Het wegschrijven van het Ribasim netwerk</li> </ol>"},{"location":"notebooks/bouw_ribasim_schematisatie/#modelnaam-en-clip-mask","title":"Modelnaam en clip-mask\u00b6","text":"<p>Hieronder hebben we een optie om een model te maken van heel Nederland of een stukje Nederland:</p> <ul> <li><code>model_name</code>: naam voor het Ribasim model</li> <li><code>mask_poly</code>: GeoPackage met polygon</li> </ul>"},{"location":"notebooks/bouw_ribasim_schematisatie/#1-inlezen-lhm-netwerk","title":"1. Inlezen LHM-netwerk\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#2-basin-knopen","title":"2. Basin-knopen\u00b6","text":"<p>We lezen de DM en LSW \"knopen\" in als Basins (<code>1</code>) en maken de basin-profielen voor LSWS (<code>2</code>) en DM (<code>3</code>). We maken hiervoor een GeoDataFrame (<code>4</code>) dat RIBASIM in kan.</p>"},{"location":"notebooks/bouw_ribasim_schematisatie/#21-basin-knopen","title":"2.1. Basin knopen\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#22-lsw-saqh-profielen-inlezen","title":"2.2. LSW SAQ(h) profielen inlezen\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#23-dm-profielen-inlezen","title":"2.3. DM profielen inlezen\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#24-profielen-combineren","title":"2.4 Profielen combineren\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#3-bouw-netwerk","title":"3. Bouw netwerk\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#31-tussen-lhm-links","title":"3.1. Tussen LHM links\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#31-toevoegen-boundaries","title":"3.1. Toevoegen boundaries\u00b6","text":""},{"location":"notebooks/bouw_ribasim_schematisatie/#4-wegschrijven-model","title":"4. Wegschrijven model\u00b6","text":""}]}